

## 问答解说

### HTML

#### HTML标签有哪些？

行内元素：相邻的行内元素会排列在同一行，不会独占一行，且设置宽高无效、margin上下无效、padding上下无效。。有span a br I em img input select span sub sup u textarea。

块级元素：会独占一行，且可以设置宽高等属性。有div h1-h6 hr p ul ol table address blockquote dir from menu。

可变元素：根据上下文预警决定该元素为块级元素还是内联元素。有button del iframe ins。



#### HTML5 新增的内容有哪些？

①新增语义化标签、新增表单类型、表单元素、表单属性、表单事件、多媒体标签。新增语义化标签有：header 页面头部、 main 页面主要内容、 footer 页面底部、 Nav 导航栏、 aside 侧边栏、 article 加载页面一块独立内容、 section 加载独立内容、 mark 高亮显示、 dialog 加载对话框标签（必须配合 open 属性）。

②拖拽释放(Drag and drop) API；画布(Canvas) API；地理(Geolocation) API；音频、视频API(audio,video)；localStorage和sessionStorage；web worker和 websocket。其中，web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了

注：新增的表单属性有datalist、datetime、output、keygen、date、month、week、time、number、range、emailurl。



#### 如何理解HTML结构的语义化？

①更符合W3C统一的规范标准，是技术趋势。

②没有样式时，浏览器的默认样式也能让页面结构很清晰。

③对功能障碍用户友好。屏幕阅读器（如果访客有视障）会完全根据标记来“读”网页。

④对其他非主流终端设备友好。例如机顶盒、PDA、各种移动终端。

⑤对SEO友好。



#### 怎么理解HTML语义化标签？

HTML5 语义化标签是指正确的标签包含了正确的内容，其优点是结构良好且清晰、提升可访问性、有利于seo、利于维护、 便于阅读（使阅读源代码的人对网站更容易将网站分块）等等。

常见的语义化标签有article、footer、header、nav、section等。



#### 做好SEO需要考虑什么？

因为搜索引擎主要以外链数量和质量、网页内容和结构等来决定某关键字下的网页搜索排名。所以前端应该注意网页结构和内容方面的情况：

①Meta标签优化：主要包括主题（Title)、网站描述(Description)、还有一些其它的隐藏文字，如Author（作者）、Category（目录）、Language（编码语种）等符合W3C规范的语义性标签的使用。

②选取关键词并在网页中放置关键词：因为搜索就得用关键词，关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density）、相关度（Relavancy）、突出性（Prominency）等。



#### DIV+CSS布局的优缺点？

①代码精简，且结构与样式分离，易于维护。

②代码量减少了，减少了大量的带宽，页面加载的也更快，提升了用户的体验。

③新增了许多语义化标签，对SEO搜索引擎更加友好。

④允许更多炫酷的页面效果，丰富了页面。

⑤符合W3C标准，保证网站不会因为网络应用的升级而被淘汰。

缺点：不同浏览器对web标准默认值不同，所以更容易出现对浏览器的兼容性问题。



#### 怎么实现标签的禁用？

添加 disabled 属性。



#### 如何在页面嵌入和使用视频/音频？

视频标签属性：
src 需要播放的视频地址；
width/height 设置播放视频的宽高，和 img 标签的宽高属性一样；
autoplay 是否自动播放；
controls 是否显示控制条；
poster 没有播放之前显示的展位图片；
loop 是否循环播放；
preload 预加载视频（缓存）与 autoplay 相冲突，设置了 autoplay 属 性，preload 属性会失效；
muted 静音模式。

```html
<video src=""></video>或
<video width="450" height="340" controls>
	<source src="jamshed.mp4" type="video/mp4">
	Your browser does'nt support video embedding feature.
</video>
```

音频属性和视频属性差不多，不过宽高和 poster 属性不能用。

```html
<audio> <source src="" type=""> </audio>或
<audio controls>
	<source src="jamshed.mp3" type="audio/mpeg">
	Your browser does'nt support audio embedding feature.
</audio>
```



#### 解决a标签点击后hover事件失效的问题？

改变a标签css属性的排列顺序，只需要记住 LVHA 原则就可以了（link→visited→hover→active）。如果visited在hover后面，则hover事件就失效了。

`a:link`：未访问时的样式，一般省略成`a`。`a:visited`：已经访问后的样式。`a:hover`：鼠标移上去时的样式。`a:active`：鼠标按下时的样式。



#### 如何使用label标签？

label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

```html
<label for="Name">Number:</label>
<input type=“text“name="Name" id="Name"/>
<label>Date:<input type="text" name="B"/></label>
```



#### img的alt与title有何异同？

alt(alt text)：为不能显示图像时显示，alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下，会在没有title时，把alt当成 tool tip显示)

title(tool tip)：该属性为设置该属性的元素提供建议性的信息。



#### HTML5的form如何关闭自动完成功能？

给不想要提示的 form 或某个 input 设置一个属性为 autocomplete=off。



#### title与h1的区别、b与strong的区别、i与em的区别？

title标签没有明确意义，表示的是文档标题；h1则表示层次明确的标题，对页面信息的抓取也有很大的影响。

strong是标明重点内容，有语气加强的含义，使用阅读设备阅读时，<strong> 会重读，而 <b>只是展示强调内容。

em表示强调的文本，而i只是将内容展示为斜体。



#### 简述一下src与href的区别？

src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。

src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本`<script src =”js.js”></script>`，img图片和frame等元素；当浏览器解析到该元素时，会暂停其它资源的下载和处理，直到将该资源加载、编译、执行完毕；图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内，这也是为什么将js脚本放在底部而不是头部。

href是Hypertext Reference的缩写，指向网络资源所在位置，建立和元素（锚点）或文档（链接）之间的链接，如果我们在文档中添加`<link href="common.css" rel="stylesheet"/>`，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css相关资源，而不是使用@import方式。



#### link与@import导入css的区别？

①link是XHTML标签，除了加载CSS外，还可以定义RSS等其它事务，还能通过`rel="alternate stylesheet"`指定候选样式；@import属于CSS范畴，只能加载CSS。

②link引用CSS时，在页面载入时同时加载，并最大限度支持并行下载；@import需要页面网页完全载入以后加载。

③link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

④link支持使用Javascript控制DOM去改变样式；而@import不支持。



#### div+css的布局较table布局有什么优点？

正常场景一般都适用div+CSS布局，优点：
①结构与样式分离；
②代码语义性好；
③更符合HTML标准规范；
④SEO友好；

之所以现在逐渐淘汰了 table 系表格元素，是因为用 div+css 编写出来的文件比用table 编写出来的文件小，table的嵌套性太多，没有 div 简洁，且div是逐行显示，而 table 是在页面完全加载后才显示。

table布局的适用场景：某种原因不方便加载外部CSS的场景（如邮件正文），此时用table布局可以在无css情况下保持页面布局正常。



#### 每个HTML文件里开头的Doctype的作用？

该声明位于文档中的最前面的位置。此标签用于声明文档类型，并可告知浏览器文档使用哪种 HTML 或 XHTML 规范，告诉浏览器按照何种规范解析页面。如通过DOCTYPE声明新增的结构元素和功能元素来区分HTML和HTML5。

IE下如不书写文档声明，则会使用怪异模式（兼容模式）解析网页，导致一系列CSS兼容性问题。



#### HTML5 为什么只需要写`<!DOCTYPE HTML>`？

HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。

而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。



#### Canvas元素有什么用

Canvas 元素用于在网页上绘制图形，通过该元素标签可以直接在 HTML 上进行图形操作。



#### window到body的层级关系？

window > document > html > body。

层级关系：window 是 BOM 的核心对象，它一方面用来获取或设置浏览器的属性和行为，另一方面作为一个全局对象；document 对象是一个跟文档相关的对象，拥有一些操作文档内容的功能。但是地位没有window 高；html 元素对象和 document 元素对象是属于 html 文档的 DOM 对象，可以认为就是 html 源代码中那些标签所化成的对象。



### CSS

#### 请简述 css 盒子模型？

一个 css 盒子从外到内可以分成四个部分：margin（外边距），border （边框），padding（内边距），content（内容）。默认情况下，盒子的 width 和 height 属性只是设置 content（内容）的宽和高；盒子真正的宽应该是：内容宽度+左右填充+左右边距+左右边框；盒子真正的高应该是：内容高度+上下填充+上下边距+上下边框。



#### CSS伪类选择器有哪些，还有哪些选择器，优先级如何计算？ 

CSS伪类选择器有：a:link/visited/hover/active。构伪类选择器： 查找第几个nth-child(n)查找同一类型第几个，nth-of-type查找唯一类型。

其它的CSS选择器有：id 选择器，class（类）选择器，标签（元素）选择器，伪元素选择器，群组选择器，*通配符选择器，后代选择器。

优先级（权重）：

浏览器默认样式 0.01；
浏览器用户自定义样式 0.1；
元素选择器 1；
伪元素选择器 1；
class 选择器 10；
伪类选择器 10；
属性选择器 10；
Id 选择器 100；
内联样式的权重 1000；
带有!important 标记的样式属性的优先级最高；



#### CSS3新增的内容有哪些？

边框：
border-radios 添加圆角边框；
border-shadow：给框添加阴影（水平位移，垂直位移，模糊半径，阴影尺寸，阴影颜色，insetr内外部阴影）；
border-image：设置边框图像；
border-image-source 边框图片的路径;
border-image-slice 图片边框向内偏移;
border-image-width 图片边框的宽度；
border-image-outset 边框图像区域超出边框的量；
border-image-repeat 图像边框是否平铺（repeat 平铺 round 铺满 stretch 拉伸）；

背景：
background-size 背景图片尺寸；
background-origin 规定background-position属性相对于什么位置定位；
background-clip 规定背景的绘制区域（padding-box，border-box，content-box）；

渐变：
linear-gradient() 线性渐变；
radial-gradient() 径向渐变；

文本效果：
word-break：定义如何换行；
word-wrap：允许长的内容可以自动换行；
text-overflow：指定当文本溢出包含它的元素，应该干啥；
text-shadow：文字阴影（水平位移，垂直位移，模糊半径，阴影颜色）；

转换：
transform 应用于 2D3D 转换，可以将元素旋转，缩放，移动，倾斜；
transform-origin 可以更改元素转换的位置，（改变 xyz 轴）；
transform-style 指定嵌套元素怎么样在三位空间中呈现；

2D 转换方法： 
rotate 旋转；
translate(x,y) 指定元素在二维空间的位移；
scale(n) 定义缩放转换；

3D 转换方法： 
perspective(n) 为 3D 转换 translate rotate scale；

过渡：
transition-property 过渡属性名；
transition-duration 完成过渡效果需要花费的时间；
transition-timing-function 指定切换效果的速度；
transition-delay 指定什么时候开始切换效果；

动画：
animation；
animation-name 为@keyframes动画名称；
animation-duration 动画需要花费的时间；
animation-timing-function 动画如何完成一个周期；
animation-delay 动画启动前的延迟间隔；
animation-iteration-count 动画播放次数；
animation-direction 是否轮流反向播放动画。



#### CSS中可继承的属性有哪些？

CSS继承特性主要是文本方面。

所有元素都可继承：visibility 和 cursor；
块级元素可继承：text-indent 和 text-align；
列表元素可继承：list-style，list-style-type，list-style-position， list-style-image；
内联元素可继承：字母间距letter-spacing，段落间距word-spacing，行高line-height，字体颜色color， font，字体种类font-family，字体大小font-size，字体样 式font-style ， font-variant ， 字体粗细font-weight ， 文本修饰text-decoration ， 转换不同元素中的文本text-transform，文 本方向direction。



#### css动画如何实现？

创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现， 动画的实际表现是由@keyframes规则实现的，具体情况参见使用 keyframes 定义动画序列部分。

transition 也可实现动画，但是transition强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（如hover）时才能获取样式，这样就会产生过渡动画。



#### transform、translate、transition、animation分别是什么属性？

transform 是指变换、变形，是 css3 的一个属性，和 width、height 属性一样。

translate 是 transform 的属性值，是指元素进行 2D(3D)维度上的位移或范围变换。

transition 是指过渡效果，往往理解成简单的动画，一般定义开始结束两个状态，需要有触发条件。

animation 引入了关键帧、速度曲线、播放次数等概念，更符合动画的定义，且无需触发条件。



#### 关于CSS3动画和JS动画的差异性？

区别：

①功能涵盖面，JS 比 CSS 大，实现/重构难度不一，CSS3比JS更加简单。



#### 介绍animation和steps()功能符？

用法：`animation: name duration timing-function delay iteration-count direction;`。

animation-name：规定需要绑定到选择器的 keyframe 名称。
animation-duration：规定完成动画所花费的时间，以秒或毫秒计。
animation-timing-function：规定动画的速度曲线（ease|linear|ease-in|cubic-bezier(n,n,n,n)）。
animation-delay：规定在动画开始之前的延迟。
animation-iteration-count：规定动画应该播放的次数，（n | infinite）n次/无限。
animation-direction：规定是否应该轮流反向播放动画，（normal | alternate）正常/反向。

steps()功能符可以让动画不连续，和贝塞尔曲线（cubic-bezier() 修饰符）一样都可以作为 animation 的第三个属性值。有 number 和 position 两个关键字，语法`steps(number, position)`。number是数值，表示把动画分成了多少段。position表示动画是从时间段的开头连续还是末尾连续，支持 start 和 end 两个关键字，start表示直接开始，end（默认）表示戛然而止。



#### 比较`opacity: 0;`、`visibility: hidden;`、`display: none;`的区别？

它们都能让元素不可见，区别是：

①结构：

`display: none;`会让元素完全从渲染树中消失，渲染的时候不占据任何空间，不能点击。
`visibility: hidden;`不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击。
`opacity: 0;`不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击。

②继承：

`display: none;`和`opacity: 0;`是非继承属性，子孙节点消失是由于元素从渲染树消失造成，通过修改子孙节点属性仍无法显示。
`visibility: hidden;`是继承属性，子孙节点消失由于继承了hidden，可通过设置`visibility: visible;`可以让子孙节点显示。

③性能：

`display: none;`会造成文档回流，读屏器不会读取`display: none;`元素内容，性能消耗较大。
`visibility: hidden;`和`opacity: 0`只会造成本元素的重绘，性能消耗较少，读屏器会读取`visibility: hidden;`元素内容。



#### 比较`display: block;`、`display: inline;`的区别？

block 元素特点：

①处于常规流中时，如果 width 没有设置，则会自动填充满父容器。
②可以应用 margin和padding 。
③在没有设置高度的情况下会扩展高度以包含常规流中的子元素。
④处于常规流中布局时在前后元素位置之间（独占一个水平空间）。
⑤忽略 vertical-align。

inline 元素特点：
①水平方向上会依次布局。
②不会在元素前后进行换行。
③受 white-space 控制。
④margin和padding 在竖直方向上无效，在水平方向上有效。
⑤非替换行内元素的行框高由 line-height 确定，使用width和height 属性无效，宽度由元素内容决定，而替换行内元素的行框高由 height、margin、padding、border决定。
⑥浮动或绝对定位时会转换为 block。
⑦vertical-align 属性生效。



#### 清除浮动的方式及其优缺点？

当所有的子元素浮动的时候，且父元素没有设置高度，这时候父元素就会产生高度塌陷，需要通过清除浮动解决。 清除浮动方式：

①给父元素单独定义高度。
优点：快速简单，代码少。
缺点：无法进行响应式布局。

②父级定义`overflow：hidden;zoom：1;`（针对 ie6 的 兼容）。
优点：简单快速、代码少，兼容性较高。
缺点：超出部分会被隐藏。

③父级定义`overflow: auto;`。
优点：简单，代码少，兼容性好。
缺点：内部宽高超过父级 div 时，会出现滚动条。

④在浮动元素后面加一个空标签，且其属性设置为`clear: both;height: 0;overflow: hidden;`。
优点：简单快速、代码少、兼容性较高。
缺点：增加空标签，不利于页面优化。

⑤额外标签法：在父元素内容的最后添加一个块级元素，并其设置`clear: both;`。

⑥给塌陷元素添加伪对象，如`.father::after{ content：“随便写”； clear：both;display：block;height：0;overflow：hidden;visibility：hidden; }`，或`.clearfix::before, .clearfix::after { content:""; display:table; }   .clearfix::after{ clear:both; overflow:hidden; }   .clearfix{ zoom:1; }`（用`display:table;`是为了避免外边距margin重叠导致的margin塌陷，内部元素默认会成为 table-cell 单元格的形式）。
优点：写法固定，兼容性高。
缺点：代码多。



#### 介绍双边距重叠问题（外边距折叠）？

多个相邻（兄弟或者父子关系）普通流的块元素的垂直方向 marigin 会重叠。

折叠的结果为：
①两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
②两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
③两个外边距一正一负时，折叠结果是两者的相加的和。



#### 什么是块级格式化上下文？

A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other。块格式化上下文是 CSS 可视化渲染的一部分，它是一块区域，规定了内部块盒的渲染方式，以及浮动相互之间的影响关系。当元素设置了 overflow 样式且值部位 visible 时，该元素就构建了 一个 BFC，BFC 在计算高度时，内部浮动元素的高度也要计算在内，也就是说即使 BFC 区域内只有一个浮动元素，BFC 的高度也不会发生塌缩，所以达到了清除浮动的目的。

BFC触发条件：①根元素，即html。②float的值不为none（默认）。③position的值为absolute或fixed。④overflow的值不为visible（默认）。⑤display的值为inline-block、table-cell、table-caption。

BFC特性：内部的Box会在垂直方向上一个接一个放置；（相邻的）Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠；每个元素的margin box 的左边，与包含块border box的左边相接触；BFC的区域（内部）不会与float box重叠（可用于清浮动）；BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素；计算BFC的高度时，浮动元素也会参与计算。



#### border-box与content-box的区别？

CSS盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括边距、边框、填充和实际内容。

content-box：W3C盒模型，又名标准盒模型，width不包括 padding 和 border，一个块的总宽度=width+margin(左右)+padding(左右)+border(左右)。
border-box：IE盒模型，又名怪异盒模型，width包括 padding 和 border，一个块的总宽度=width+margin（左右）。



#### 介绍弹性盒子布局（Flex）及其属性？

Flex 布局原理：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式。

flex-direction：弹性容器中子元素排列方式（主轴排列方式）；
flex-wrap：设置弹性盒子的子元素超出父容器时是否换行；
flex-flow：是 flex-direction 和 flex-wrap 简写形式；
align-item：设置弹性盒子元素在侧轴上的对齐方式；
align-content：设置行对齐；
justify-content：设置弹性盒子元素在主轴上的对齐方式；



#### 定位的属性值及其区别？

position 有六个属性值：static relative absolute fixed sticky inherit。

static 默认值，元素出现在正常的流中。
relative 相对定位，不脱离文档流，相对于自身定位。如果对一个元素进行相对定位，它将出现在它所在的位置上； 可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行“移动”；在使用相对定位时，无论是否进行“移动”，元素仍然占据原来的空间，因此，“移动”元素会导致它覆盖其它元素。
absolute 绝对定位，脱离文档流，相对于父级定位。绝对定位的元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，那么它的位置相对于html；absolute 定位使元素的位置与文档流无关，因此不占据空间；absolute 定位的元素会和其它元素有重叠。
fixed 固定定位，脱离文档流，相对于浏览器窗口定位。即使窗口是滚动的，它也不会移动；Fixed 定位使元素的位置与文档流无关，因此不占据空间；Fixed 定位的元素和其它元素会有重叠。
sticky 粘性定位，元素先按照普通文档流定位，然后再相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位；默认定位为static。
inherit 规定应该从父元素继承 position 属性的值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。



#### 子元素如何在父元素中居中

水平居中：

①子父元素宽度固定，子元素设置 margin：0 auto，并且子元素不能设置浮动，否则居中失效。
②子父元素宽度固定，父元素设置 text-align：center，如果子元素是块级元素则设置 display：inline-block，并且子元素不能设置浮动，否则居中失效。
③若子元素包含 float:left 属性, 可让父元素宽度设置为fit-content，并且margin:0 auto;。

水平垂直居中： 

①子元素相对于父元素绝对定位，子元素 top，left 设置 50%，子元素 margin-top 和 margin-left 减去各自宽高的一半。
②子元素相对于父元素绝对定位，子元素上下左右全为 0，然后设置子元素 margin:auto;。
③父元素设置 display:table-cell;vertical-align:middle;，子元素设置margin:auto;。
④父元素相对定位，子元素绝对定位，子元素 top和left 值为 50%、transform:translate(-50%, -50%)。
⑤父元素设置弹性盒子，display: flex; justfy-content: center; align-item: center; justfy-content: center;。
⑥父元素设置display: table;，子元素 display: table-cell;vertical-align: middle;

垂直居中：

①设置子元素和父元素的行高一样。
②子元素设置为行内块，再加 vertical-align: middle;。
③已知父元素高度，子元素相对定位，通过 transform：translateY（-50%）。
④不知道父元素高度，子绝父相，子元素 top：50%，transform： translateY(-50%)。
⑤给父元素设置display:table，子元素 display:table-cell;vertical-align:middle;。
⑥弹性盒，父元素 display:flex，子元素 align-self:center。



#### 如何实现左右等高布局

①使用table布局，兼容性最好。

```html
<div class="layout">
	<div class="layout left">left</div>
	<div class="layout right">right</div>
</div>
<style>
.layout{
	display: table;
	width: 100%;
}
.layout div{
	display: table-cell;
}
.layout .left{
	width: 50%;
	height: 200px;
	background: red;
}
.layout .right{
	width: 50%;
	background: yellow;
}
</style>
```

②使用flex布局的的align-items: stretch;。



#### margin 和 padding 的使用场景？

当需要在 border 外侧添加空白时用 margin，当需要在 border 内侧添 加空白时用 padding。



#### CSS各种布局单位（如px、em等）的区别？

px，绝对长度单位，像素 px 是相对于显示器屏幕分辨率来说的。

em，相对长度单位，相对于当前对象内文本的字体尺寸，em的值并不是固定的，em会继承父级元素的字体大小（参考物是父元素的 font-size），em中所有的字体都是相对于父元素的大小决定的。

rem，相对于 html 根元素的 font-size，默认1em=1rem=16px。假如在 body 中加入 font-size：62.5%，则原来的 px 数值(n)px，可以替换为(n/10)em。



#### 移动端中不同手机html默认字体大小都一样吗？

如果没有人为去改变根元素字体大小，则默认是 1rem = 16px。根元素默认的字体大小是16px。



#### 如何让 chrome 浏览器显示小于 12px 的文字？

添加谷歌私有属性-webkit-text-size-adjust: none; -webkit-transform: scale();。



#### CSS预处理（sass和less）是什么？

Sass 和 Less 都是 css 预处理器，是 css 上的一种抽象层，是一种特殊的语法，最终会编译成 css。

Less 是一种动态样式语言，给 css 赋予了动态语言的特性（如变量、继承、嵌套）；Less 既可以在客户端运行，也可以在服务端运行（需要借助node）。



### JS

#### JS的语言特性有哪些？

运行在客户端浏览器上；不用预编译，直接解析执行代码；是弱类型语言，较为灵活，也是动态类型语言，运行的时候才知道每个变量的类型；与操作系统无关，是跨平台的语言；是脚本语言，也是解释性语言。



#### 为什么 js 是弱类型语言？

弱类型语言是相对于强类型语言来说的。

在强类型语言中，变量类型有多种，比如 int char float Boolean；不同类型相互转换，有时需要强制转换；而 javascript 只有一种类型 var，为变量赋值时会自动判断类型并转换，所以是弱类型语言。



#### 怎么理解js的内置对象？

JS中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其它对象的构造函数对象。

js的标准内置对象分为全局对象（内置对象）和global对象。



#### 怎么理解DOM和BOM？

广义JS=ECMAScript + DOM + BOM核心语法。

DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global对象，这意味着在网页中定义的任何对象、变量和函数，都作为全局对象的一个属性或方法存在。window 对象含有location对象、navigator对象、screen对象、history对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。



#### JS的数据类型有哪些？

JS可分为两种类型的值，主要区别是它们的存储位置不同。基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。

①基本数据类型：字符串string、数值number、布尔值boolean、null、undefined、symbol、bigint。

②复杂数据类型：对象。



#### 判断js的数据类型的方式有哪些？

①typeof：可以判断出'string'、'number'、'boolean'、'undefined'、'symbol'、'function'，但判断null和数组和对象时，值为 'object'。

②instanceof：原理是构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

③Object.prototype.toString.call()：常用于判断浏览器内置对象，对于所有基本的数据类型都能进行判断。

④Array.isArray()：用于判断是否为数组。



#### null与undefined的区别？

相同点：都是基本数据类型，用 if 判断时，两者都会被转换成 false。

不同点：
①number 转换的值不同 number(null)为 0；number(undefined)为 NaN。
②null表示一个值被定义了，且这个值是空值（空对象）；undefined表示变量声明了但未赋值（未定义）。

使用场景：null主要用于赋值给一些可能会返回对象的变量，作为初始化。如果null作为函数的参数，表示该函数的参数不是对象，且作为对象原型链的终点。如果对象没有赋值属性，则该属性的值为undefined；在调用函数时，应该提供的参数没有提供，该参数等于undefined；函数没有返回值时，默认返回undefined。



#### 如何理解undeclared？

没有在作用域中声明过的变量，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如`ReferenceError: b is not defined`。但可以用 typeof 的安全防范机制来避免报错，因为对于undeclared（或not defined）变量，typeof 会返回 "undefined"。



#### 什么情况会发生布尔值的隐式强制类型转换？

①`if (..)`语句中的条件判断表达式。
②`for ( .. ; .. ; .. )`语句中的（第二个的）条件判断表达式。
③`while (..)`和`do..while(..)`循环中的条件判断表达式。
④`? : `中的条件判断表达式。
⑤逻辑运算符`|| 逻辑或`和`&& 逻辑与`的（左边的）操作数（作为条件判断表达式）。



#### 操作符==的强制类型转换规则？

①字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
②其它类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再用其它规则进行比较。
③null 和 undefined 之间的相等比较，不会转换成其它任何值，但结果为真，ECMAScript 规范中是这样定义的，其它值和它们进行比较都返回假值。
④对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。
⑤NaN和其它值之间的相等比较，返回 false（NaN本身也不等于NaN）。
⑥两个操作值都是对象，则比较它们是不是指向同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回 true，否则返回 false。



#### 如何判断一个数据是NaN？

①NaN，非数字，但是用 typeof 检测是，number 类型。

②利用 NaN 的定义 用 typeof 判断是否为 number 类型，并且判断是否满足 isNan。

③利用 NaN 是唯一一个不等于任何自身的特点 n!==n。

④利用 ES6 中提供的 Object.is()方法（判断两个值是否相等）。



#### isNaN和Number.isNaN函数的区别？

函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对 NaN 的判断更准确。



#### Object.is()、== 、===的区别？

使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。

使用三等号进行相等判断时，如果两边的类型不一致，不会做强制类型准换，直接返回 false。

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，但它处理了一些特殊的情况，如 -0 和 +0 不再相等、两个 NaN 认定是相等的。



#### 什么是假值对象？

浏览器在某些特定情况下，在常规 JavaScript 语法基础上创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性等），但将它们强制类型转换为布尔值时，结果为 false。

最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。



#### 怎么理解类数组对象？

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有arguments、DOM方法的返回结果、函数（因为含有 length属性值，代表可接收的参数的个数）。

常见的类数组转换为数组的方法有：
①通过 call 调用数组的 slice 方法来实现转换，`Array.prototype.slice.call(arrayLike);`。
②通过 call 调用数组的 splice 方法来实现转换，`Array.prototype.splice.call(arrayLike, 0);`。
③通过 apply 调用数组的 concat 方法来实现转换，`Array.prototype.concat.apply([], arrayLike);`。
④通过 Array.from 方法来实现转换，`Array.from(arrayLike);`。



#### ES6有哪些新特性？

const 和 let、模板字符串、箭头函数、函数的参数默认值、对象和数组 解构、for...of 和 for...in、ES6 中的类。



#### ES5和ES6分别声明变量的方式？

ES5 有两种：var和function。

ES6 有六种：除了上面两种还有let 、const 、class和import，注意let 、 const 、 class 声明的全局变量再也不会和全局对象的属性挂钩。



#### let 与 var 与 const 的区别是什么？

var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会存在变量提升；

同一作用域下 var 可以声明同名变量，let 和 const不可以；

let 和 const 声明会形成块级作用域；

const 一旦声明必须赋值，不能用 null 占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性。



#### 如何理解整数的安全范围？

安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数（2^53 - 1），即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。

如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。



#### 什么是面向对象？

面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节，这种思想是将数据作为第一位，这是对数据一种优化，操作起来更加的方便，简化了过程；

JS本身是没有 class 类型的，但是每个函数都有一个 prototype 属性， prototype 指向一个对象，当函数作为构造函数时，prototype 就起到类似于 class 的作用；

面向对象有三个特点：封装（隐藏对象的属性和实现细节，对外提供公共访问方式）， 继承（提高代码复用性，继承是多态的前提），多态（是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象）。



#### 如何理解JS中的垃圾回收机制？

JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便能够被再次使用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。这段话解释了为什么系统需要垃圾回收，JS 不像 C/C++，它们有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到程序何时不再使用一个对象了，当它确定了一个对象是无用的时候，它就不再需要这个对象，就可以把它所占用的内存释放掉了。V8引擎帮助实现了自动的垃圾回收管理，利用浏览器渲染页面的空闲时间进行垃圾回收。（如`var a="hello world"; var b="world"; var a=b;`，这时，会释放掉"hello world"）

JS进行垃圾回收的方法有： 标记清除法和计数引用法。

标记清除法是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“，从逻辑上讲，永远不能释放进入环境的变量所占的内存，只要执行流程进入相应的环境，就可能用到它们。当离开环境时，就标记为离开环境。垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量因为无法在环境变量中被访问所以会被删除。最后垃圾回收器完成了内存的清除工作， 并回收它们所占用的内存。

引用计数法是另一种不太常见的方法，引用计数法的意思就是计算每个值被引用的次数。当声明了一个变量，并用一个引用的值赋值给该变量，则这个值的引用次数为1；相反的，如果该变量又重新赋了另外一个值，则原先的引用的值的引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把其所占的内存给回收回来。这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。

但是，用引用计数法会存在内存泄露，原因：`function problem() { var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA; }`，在这个例子里面，函数执行完成之后，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。特别是在DOM对象中，也容易存在这种问题，如`var element=document.getElementById(’‘); var myObj=new Object(); myObj.element=element; element.someObject=myObj;`，这样就不会有垃圾回收的过程。



#### 闭包是什么及其特性？

闭包可以简单理解成：定义在一个函数内部的函数，即闭包就是能够读取其它函数内部变量的函数（即指有权访问其它函数作用域中的变量）。其中一个内部函数，在包含它的外部函数之外被调用时，子函数（内部函数）所在的父函数的作用域不会被释放，就会形成闭包。

特点：
①函数嵌套函数。
②函数内部可以引用外部的参数和变量。
③参数和变量不会被垃圾回收机制回收。

使用：读取函数内部的变量，这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。

优点： 

①变量长期存储在内存中（缓存变量），如结果缓存，当处理一个耗时的函数对象，可以把计算出来的值用闭包的方式存储起来，下次再调用这个函数的时候，首先在缓存中查找即可； 

②避免全局变量的污染，如匿名自执行函数，这种函数只需要执行一次，其内部变量无需维护；

③私有成员的存在 ； 

缺点：会增加内存使用量，会造成内存泄露。



#### 怎么理解JS的作用域链？

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

作用域链的本质上是一个指向变量对象的指针列表，变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象，全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。



#### 什么是内存泄漏及常见的内存泄漏有哪些？

内存泄漏是指一块被分配的内存既不能使用又不能回收，直到浏览器进程结束为止。释放内存的方法：赋值为 null。

常见的内存泄漏有：①意外的全局变量。②被遗忘的计时器或回调函数。③脱离 DOM 的引用。即获取一个 DOM 元素的引用，后面这个元素被删除，但由于一直保留了对这个元素的引用，所以它也无法被回收。④闭包。



#### 如何实现浅拷贝和深拷贝？

浅拷贝：第一层为深拷贝，如用`Object.assign()`、`Array.prototype.slice()`、`...`扩展运算符。

深拷贝：`JSON.parse(JSON.stringify())`和递归函数。



#### mouseover和mouseenter的区别？

mouseover：当鼠标移入元素或其子元素时，都会触发事件，所以有一个重复触发、冒泡的过程。对应的移出事件是 mouseout。

mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移出事件是 mouseleave。



#### 怎么使用原生的自定义事件？

创建自定义事件：原生自定义事件有三种写法。

①使用Event：`let myEvent = new Event('event_name');`。

②使用`customEvent`（可以传参数）。

```javascript
let myEvent = new CustomEvent('event_name', {
    detail: {
        // 将需要传递的参数放到这里 // 可以在监听的回调函数中获取到：event.detail
    }
})
```

③使用 `document.createEvent('CustomEvent')`创建一个事件和 `initEvent`初始化一个事件。

```javascript
let myEvent = document.createEvent('CustomEvent');
myEvent.initEvent(
    // 1. event_name: 事件名称 // 2. canBubble: 是否冒泡 // 3. cancelable: 是否可以取消默认行为
)
```

事件的监听：使用 addEventListener 监听，`button.addEventListener('event_name', function (e) {})`，第三个参数默认为true表示在捕获阶段调用事件处理程序。对于执行顺序的问题，如果 DOM 节点同时绑定了两个事件监听函数，则绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡。

事件的触发：触发自定义事件使用 dispatchEvent(myEvent)，这里的参数是自定义事件的对象，`button.dispatchEvent(myEvent)`。



#### 什么是事件委托及如何确定事件源（event.target）？

事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。事件委托就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。

事件委托，称事件代理，是 js 中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务，事件委托的原理是 DOM 元素的事件冒泡。

优点：使代码更简洁和节省内存开销，比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。



#### DOM事件有哪些阶段？

一个事件触发后，会在子元素和父元素之间传播，这种传播（事件流）分为三个阶段：

①捕获阶段，从 window 对象传导到目标节点（从外到里），这个阶段不会响应任何事件。

②目标阶段，在目标节点上触发。

③冒泡阶段，从目标节点传导回 window 对象（从里到外），事件委托/事件代理就是利用事件冒泡的机制把里层需要响应的事件绑定到外层。

注意，IE 只支持事件冒泡。



#### 所有的事件都有冒泡吗？

并不是所有的事件都有冒泡的，如onblur、onfocus、onmouseenter、onmouseleave事件就没有。



#### 怎么理解JS执行机制（事件循环）？

JavaScript语言的一大特点就是单线程，同一个时间只能做一件事。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous），在所有同步任务执行完之前，任何的异步任务是不会执行的。

同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入 Event Table 并注册函数。当指定的事情完成时，Event Table会将这个函数移入 Event Queue。主线程内的任务执行完毕（因为js引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数），会去 Event Queue 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 Event Loop（事件循环）。 

JS 异步中，宏任务（macrotasks）和微任务 （microtasks）执行顺序（先微后宏）：JS 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 Event Queue，然后再执行微任务，将微任务放入 Event Queue，但是，这两个 Queue 不是一个 Queue，当往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的 Queue 拿宏任务的回调函数。

微任务：Promise、process.nextTick。宏任务：整体代码script、setTimeout、setInterval、I/O操作、UI渲染。



#### 本地存储（localStorage与sessionStorage）与 cookie 的区别？

cookie 非常小，它的大小限制为 4KB 左右，如果使用 cookie 保存过多数据会带来性能问题。cookie数据始终在同源的http请求中携带（即使不需要），但有路径（path）的概念，可以限制cookie只属于某个路径下。它的主要用途有保存登录信息，为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。如登录某个网站时可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。

localStorage是 HTML5 标准中新加入的技术，被大多数浏览器所支持，可以达到5M或更大，但只能存字符串。

sessionStorage 与 localStorage 的接口类似，可以达到5M，但保存数据的生命周期 与 localStorage 不同。sessionStorage 是一个前端的概念， 它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。

三者的异同：

特性：Cookie、localStorage、sessionStorage数据的生命期一般由服务器生成，可设置失效时间。

如果在浏览器端生成 Cookie，则仅在当前会话下有效，默认是关闭页面或浏览器后被清除和失效。
localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
localStorage和cookie在所有同源窗口中都是共享的，而sessionStorage不在不同的浏览器窗口中共享（即使是同一个页面）。
sessionStorage 数据在当前浏览器窗口关闭后自动删除。



#### 怎么理解JS代码中的`"use strict";`？

`use strict`是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。这种模式对 js 的使用添加了一些限制。如禁止使用 with 语句、禁止 this 关键字指向全局对象、对象不能有重名的属性。

设立"严格模式"的主要目的有：
①消除 Javascript 语法的一些不合理和不严谨和不安全之处，减少一些怪异行为。
②消除代码运行的一些不安全之处，保证代码运行的安全。
③提高编译器效率，增加运行速度。
④为未来新版本的 Javascript 做好铺垫。



#### 普通函数和构造函数的区别是什么？

①构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写；

②调用方式不一样，普通函数直接调用，构造函数要用关键字 new 来调用；

③调用时，构造函数内部会创建一个新对象，就是实例，普通函数不会创建新对象；

④构造函数内部的 this 指向实例，普通函数内部的 this 指向调用函数的对象（如果没有对象调用，默认为 window）；

⑤构造函数默认的返回值是创建的对象（也就是实例），普通函数的返回值由 return 语句决定（无return则返回undefined）；

⑥构造函数的函数名与类名相同；



#### Class和构造函数的区别是什么？

class 的写法只是语法糖，但还是有细微差别的。

①class 必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。

②严格模式：类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实 际上把整个语言升级到了严格模式。

③不存在提升：类不存在变量提升（hoist），这一点与 ES5 完全不同。

④方法默认是不可枚举的：class的方法（包括静态方法和实例方法）默认是不可枚举的，而构造函数默认是可枚举的。这其实是个优化，在遍历时候不需要再判断 hasOwnProperty了。

⑤class的所有方法（包括静态方法和实例方法）都没有原型对象prototype，所以也没有[[construct]]，不能使用 new 来调用。

⑥ES5 和 ES6 子类 this 生成顺序不同：ES5的继承通过prototype或构造函数机制来实现，实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（`Parent.apply(this)`）。ES6的继承机制完全不同，通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承，这个差别使得 ES6 可以继承内置对象；子类没有自己的this对象，而是继承了父类的this对象，然后再用子类的构造函数修改this；实质上是先创建父类的实例对象并生成this，子类构造函数必须在constructor方法中调用父类的`super()`方法（super关键字指代父类的实例，即父类的this对象），调用才可使用this关键字，否则子类得不到this对象且新建实例报错。

⑦ES6可以继承静态方法，而构造函数不能。



#### 箭头函数与普通函数的区别

①箭头函数是匿名函数，不能作为构造函数，不能通过 new 关键字调用。

②箭头函数不能绑定arguments，没有自己的arguments对象，要用rest参数解决。

③箭头函数没有原型属性。

④箭头函数不能绑定 this，且箭头函数的 this 永远指向其上下文的 this，会捕获其所在的上下文的 this 值来作为自己的this值。



#### JS 的 new 操作符做了什么？

①首先创建了一个新的空对象。
②设置原型，将对象的原型设置为构造函数的 prototype 对象。
③让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。
④在函数无return的情况下，则默认返回这个新对象；在函数有return的情况下，则判断函数的返回值类型，如果是值类型，则返回创建的对象，如果是引用类型，则返回这个引用类型的对象。



#### 请简述原型/原型链/（原型）继承？

什么是原型：任何对象实例都有一个原型，也叫原型对象，这个原型对象的指向，即该对象的内置属性\_\_proto\_\_的指向（`xxx.__proto__ === xxx.constructor.prototype`），等同于它的构造函数的 prototype 所指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。

什么是原型链？原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象，每个原型对象都有一个指向该构造函数的指针，而实例又包含一个指向原型对象的内部指针。原型链的核心就是依赖对象的\_\_proto\_\_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数的显示原型，直至到 Object 时，就没有\_\_proto\_\_指向了（即Object.prototype 是没有\_\_proto\_\_属性的，它的值为null）。

原型继承是 js 的一种继承方式，原型链作为实现继承的主要方法，其基本思路是利用原型让一个引用类型继承另一个引用类型的属性和方法，原型继承利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继承，这种实现继承的方式，就叫做原型继承。

注意：`Object.prototype.constructor`等同于`Object`；`(new Object.prototype.constructor).constructor.prototype`等同于`Object.prototype`等同于`(new Object.prototype.constructor).__proto__`。



#### JS中的哪个函数在执行对象查找时不会去查找原型？

hasOwnProperty。所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，且会忽略掉那些从原型链上继承到的属性。



#### JS继承的几种实现方式？

①以原型链的方式来实现继承。这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱，还有就是在创建子类型的时候不能向超类型传递参数。

②借用构造函数的方式。这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

③组合继承。组合继承是将原型链和借用构造函数组合起来使用的一种方式，通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

④原型式继承。原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

⑤寄生式继承。思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象，这个扩展的过程就可以理解是一种继承。优点是如果某个对象不是自定义类型时，对一个简单对象实现继承，缺点是没有办法实现函数的复用。

⑥寄生式组合继承。方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。



#### 不同场景的this指向什么？

在 JavaScript 中，this 是执行上下文中的一个属性，通常指向的是该函数所属的对象（即指向最后一次调用这个方法的对象）。

在实际开发中，this 的指向可以通过四种调用模式来判断，使用构造器调用模式的优先级最高，然后是apply和call和bind的调用模式，然后是方法调用模式，然后是函数调用模式。

①构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。

②apply和call和bind的调用模式，这三个方法都可以指定调用函数的 this 指向。其中 apply 方法接收两个参数，一个是 this 绑定的对象，一个是参数数组；call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数；bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数，这个函数的 this 指向除了使用 new 时会被改变，其它情况下都不会改变。

③方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。

④函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。

⑤箭头函数里面的this，指向箭头函数所在作用域的this。

前四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。



#### 改变函数内部 this 指针的指向函数（bind、apply、call ）的区别？

通过 apply 和 call 改变函数的 this 指向，它们两个函数的第一个参数都是一样的，即表示要改变指向的那个对象；第二个参数，apply 是数组，而 call 则是 arg1,arg2...这种形式。

通过 bind 改变 this 作用域，会返回一个新的函数，这个函数不会马上执行。



#### 同步与异步（阻塞与非阻塞）的区别？

同步（阻塞）和异步（非阻塞），这两个关注的是程序在等待调用结果时的状态。

同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。

异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。



#### 如何理解Promise？

什么是 Promise？Promise 是承诺的意思，承诺它过一段时间会给你一个结果。Promise是一种解决异步编程的方案，相比于回调函数和事件来说更合理和更强大。从语法上讲，promise 是一个对象，从它可以获取异步操作的消息。由于它的 then 方法和 catch 和 finally 方法会返回一个新的 Promise，所以可以允许链式调用，解决了传统的回调地狱问题。

promise 有三种状态：pending 初始状态也叫等待状态，fulfiled 成功状态，rejected 失败状态。创造 promise 实例后，它会立即执行。

Promise 的特点：
①Promise 对象的状态不受外界影响。
②Promise 的状态一旦改变，就不会再变，任何时候都可以得到这个结果，且状态不可以逆。
③如果 Promise 内部的状态一经改变，并且有了
一个值，那么后续每次调用 .then 或者 .catch 的时候都会直接拿到该值。
④在 Promise 中，返回任意一个非 promise 的值都会被包裹成 promise 对象，且 .then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。
⑤Promise的 .then 方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，在某些时候可以认为 .catch 是 .then 的第二个参数的简便写法。
⑥Promise的 .then 或 .catch 里 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获。
⑦Promise的 .finally 方法不管 Promise 对象最后的状态如何都会执行，且其回调函数不接受任何参数，即在 .finally() 函数中是无法知道Promise 的最终的状态是 resolved 还是 rejected 的。
⑧Promise的 .finally 方法它最终返回的，默认是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的 Promise 对象。

Promise 的三个缺点：①无法取消 Promise，一旦新建，它就会立即执行，无法中途取消；②如果不设置回调函数，Promise 内部抛出的错误，不会反映到外部；③当处于 pending（等待）状态时，无法得知目前进展到哪一个阶段， 是刚刚开始还是即将完成。

可以用 Promise 来解决什么问题？ promise 是用来解决两个问题的：①回调地狱，即解决代码难以维护和常常第一个的函数的输出是第二个函数的输入这种现象；②promise 可以支持多并发的请求，获取并发请求中的数据，可以解决里面的异步的问题。



#### 如何理解promise.all？

Promise.all()方法将多个Promise实例包装成一个Promise对象（p），接受一个数组（p1,p2,p3）作为参数，数组中不一定需要都是Promise对象，但是一定具有Iterator接口，如果不是的话，就会调用 Promise.resolve将其转化为Promise对象之后再进行处理。

使用Promise.all()生成的Promise对象（p）的状态是由数组中的Promise对象（p1,p2,p3）决定的。

①如果所有的Promise对象（p1,p2,p3）都变成fullfilled状态的话，生成的Promise对象（p）也会变 成fullfilled状态， p1,p2,p3三个Promise对象产生的结果会组成一个数组返回给传递给p的回调函数。

②如果p1,p2,p3中有一个Promise对象变为rejected状态的话，p也会变成rejected状态，第一个被rejected的对象的返回值会传递给p的回调函数，且只有最先抛出的错误会被捕获，并且是被 .then 的第二个参数或后面的 .catch 捕获，但并不会影响数组中其它的异步任务的执行。

③Promise.all()方法生成的Promise对象也应该要有一个catch方法来捕获错误处理，但是如果数组中的Promise对象变成rejected状态，并且这个对象还定义了catch的方法时，那么rejected的对象会执行自己的catch方法，并且返回一个状态为fullfilled的Promise对象，Promise.all()生成的对象会接受这个Promise对象，不会返回rejected状态。



#### 请简述 async 的用法？

async 就是 generator 和 promise 的语法糖，async 就是将 generator 的*换成 async，将 yiled 换成 await。

在使用时，函数前必须加一个 async，异步操作方法前加一个 await 关键字，意思就是等一下，执行完了再继续走；await 只能在 async 函数中运行，否则会报错；await后面的Promise 如果返回的是一个错误的结果，且如果没有做异常处理，就会报错，所以可以用 try..catch 捕获一下异常就可以了。



#### 实现一个一组异步请求按顺序执行的方法？

①利用 reduce，初始值传入一个 Promise.resolve() ，之后往里面不停的叠加 .then()。

②利用 forEach，本质和 reduce 原理相同。

③利用 ES9 中的 for...await...of 来实现。



#### JS延迟加载的方式有哪些？

js 的加载、解析和执行会阻塞页面的渲染过程，所以需要 js 脚本能够尽可能的延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件，以提高页面的渲染速度。

一般有以下几种方式：

①让 JS 最后加载：一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

②defer属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

③async属性：给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

④动态创建 DOM 方式：可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。

⑤使用 setTimeout 延迟方法。



#### Jsonp的工作原理及其为什么不是真正的ajax？

Jsonp 其实就是一个跨域解决方案。

JS跨域请求数据是不可以的，但是 js 跨域请求 js 脚本是可以的。所以可以把要请求的数据封装成一个 js 语句，做一个方法的调用。跨域请求 js 脚本可以得到此脚本，得到 js 脚本之后会立即执行。可以把数据做为参数传递到方法中，就可以获得数据，从而解决跨域问题。

jsonp 原理：动态创建 script 标签和回调函数；浏览器在 js 请求中，是允许通过 script 标签的 src 跨域请求，可以在请求的结果中添加回调方法名，在请求页面中定义方法，就可以获取到跨域请求的数据。

为什么不是真正的 ajax?
ajax 和 jsonp 这两种技术在调用方式上"看起来"很像，目的也一样，都是请求一个 url，然后把服务器返回的数据进行处理，因此 jquery 和 ext 等框架都把jsonp 作为 ajax 的一种形式进行了封装；但 ajax 和 jsonp 其实本质上是不同的东西，ajax 的核心是通过XmlHttpRequest获取本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的 js 脚本；所以说，其实 ajax 与 jsonp 的区别不在于是否跨域，ajax 通过服务端代理一样可以实现跨域，jsonp 本身也不排斥同域的数据的获取；还有就是，jsonp 是一种方式或者说非强制协议，如同 ajax 一样，它也不一定非要 json 格式来传递数据，就算是字符串也行，只不过这样不利于 jsonp 提供公开服务。



#### 为什么会造成跨域或存在同源策略？

同源策略是由 NetScape 提出的一个著名的安全策略。所谓的同源，指的是协议、域名、端口都相同。浏览器为了安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。

出现跨域问题的原因：在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题，跨域问题来源于 JavaScript 的同源策略（即只有协议+主机名+端口号相同，才允许相互访问）。

当前域下的 js 脚本不能够访问其它域下的 cookie、localStorage 和 indexDB；是当前域下的 js 脚本不能够操作访问操作其它域下的 DOM；是当前域下 ajax 无法发送跨域请求。即JS只能访问和操作自己域下的资源，不能访问和操作其它域下的资源。

同源策略主要是为了保证用户信息的安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img或script 脚本请求都不会有跨域的限制，因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

同源策略可分为两种，Ajax同源策略和DOM同源策略。Ajax同源策略主要是使得不同源的页面不能获取 cookie 且不能发起 Ajax 请求，这样在一定程度上防止了 CSRF 攻击。DOM 同源策略限制了不同源页面不能获取DOM ，这样可以防止一些恶意网站在自己的网站中利用 iframe 嵌入正常网站并迷惑用户，以此来达到窃取用户信息。

当发起跨域请求时，如果是非简单请求，浏览器会帮我们自动触发 CORS 的预检请求（可以避免跨域请求对服务器的用户数据产生未预期的影响），即OPTIONS请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。需预检的请求要求必须先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。



#### 如何解决跨域问题？

解决跨域的方法可以根据实现的目的来划分。

①使用 jsonp 来实现跨域请求。主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制（但只接受GET请求方式）。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样先前定义好的回调函数就可以被调用。

②使用document.domain + iframe。将 document.domain 设置为主域名，可实现主域名下的不同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所问。如果文档中含有主域名相同而子域名不同的 iframe 的话，也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，如一个页面要和页面的中的不同源的 iframe 进行通信的问题，可以使用 location.hash 或 window.name 或 postMessage 来解决。

③使用location.hash + iframe。使用 location.hash 的方法，可以在主页面动态地修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是访问不到不同源的父级窗口的，所以不能直接修改父级窗口的 hash 值来实现通信，但可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以可以通过 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。

④使用window.name + iframe。主要是基于同一个窗口中设置了 window.name 后，不同源的页面也可以访问，所以不同源的子页面可以先在 window.name 中写入数据，然后（父页面？）跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，好处是可以传输的数据量大。

⑤使用 postMessage。postMessage是一个 h5 中新增的一个 api，通过它可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是解决 ajax 无法提交跨域请求的问题，可以使用 jsonp、cors、服务器代理、websocket 协议来解决问题。

⑥使用跨域资源共享（CORS）的方式。CORS 是一个 W3C 标准，需要浏览器和服务器同时支持，目前所有浏览器都支持该功能，因此只需要在服务器端配置就行。浏览器将 CORS 请求分成两类，简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求，即在头信息之中增加一个 Origin 字段，用来说明本次请求来自哪个源，服务器根据这个值，决定是否同意这次请求，如果Origin指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段，浏览器就会抛出一个错误，ajax 不会收到响应信息，如果成功则会包含一些以`Access-Control-`开头的字段；对于非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，收到肯定回复后才会发起请求。

⑦使用服务器来代理来访问请求（nginx代理跨域或nodejs中间件代理）。即有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。

⑧使用 websocket 协议，这个协议没有同源限制。



#### 数组方法有哪些？

push() 从后面添加元素，返回值为添加完后的数组的长度；

arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素；

arr.shift() 从前面删除元素，只能删除一个返回值是删除的元素；

arr.unshift() 从前面添加元素，返回值是添加完后的数组的长度；

arr.splice(i,n) 删除从 i(索引值)开始之后的那个元素，返回值是删除的元素；

arr.concat() 连接两个数组返回值为连接后的新数组；

str.split() 将字符串转化为数组；

arr.sort() 将数组进行排序，返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的；

arr.reverse() 将数组反转，返回值是反转后的数组；

arr.slice(start,end) 切去索引值 start 到索引值 end 的数组，不包含 end 索引的值，返回值是切出来的数组；

arr.forEach(callback) 遍历数组，无 return，即使有 return，也不会返回 任何值，并且会影响原来的数组；

arr.map(callback) 映射数组(遍历数组)，有 return 返回一个新数组；

arr.filter(callback) 过滤数组，返回一个满足要求的数组。



#### 数组去重的方式有哪些？

①使用 indexof()方法或 lastindexof()方法。

②ES6 的 set 结构，set 不接受重复数据，如`[...new Set(arr)]`或`Array.from(new Set(arr))`。

③使用 sort 方法先将原数组排序，然后与相邻的比较，如果不同则存入新数组。

④使用 filiter 和 indexof 方法。

⑤使用 includes 方法。

⑥使用 reduce 方法。

⑦使用for循环嵌套，再利用 splice 去重。



#### JS 的各种位置属性的区别？

clientHeight：表示可视区域的高度，不包含 border 和滚动条。

offsetHeight：表示可视区域的高度，包含了 border 和滚动条。

scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。

clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0。

scrollTop：滚动后被隐藏的高度。



#### DOM相关操作有哪些？

创建新节点：`createDocumentFragment(node);`、`createElement(node);`、`createTextNode(text);`

添加和移除和替换和插入：`appendChild(node)`、`removeChild(node)`、`replaceChild(new,old)`、`insertBefore(new,old)`。

查找：`getElementById();`、`getElementsByName();`、`getElementsByTagName();`、`getElementsByClassName();`、`querySelector();`、`querySelectorAll();`。

属性操作：`getAttribute(key);`、`setAttribute(key, value);`、`hasAttribute(key);`、`removeAttribute(key);`。



#### 说一下 HTML5 drag api？

dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。

darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。

dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。

dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。

dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。

drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。

dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。



#### documen.write和innerHTML和outerHTML的区别？

document.write 的内容会代替整个文档内容，会重写整个页面。

innerHTML 的内容只是替代指定元素的内部HTML内容，只会重写页面中的部分内容。

outerHTML 针对外部 HTML。



#### 介绍eval？

它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。

由JSON字符串转换为JSON对象的时候可以用eval，`var obj =eval('('+ str +')')`。



#### 介绍requestAnimationFrame？

requestAnimationFrame 是浏览器用于定时循环操作的一个接口，类似于 setTimeout ，但不需要设置时间间隔，主要用途是按帧对网页进行重绘。对于 JS 动画，用requestAnimationFrame 比 setInterval 效果更好。

特点：
①requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用，且会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中完成，重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。
②在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这意味着更少的 CPU、GPU 和内存使用量
③requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时，浏览器会自动优化方法的调用，并且如果页面不是激活状态下，则动画会自动暂停，有效节省了CPU 开销。



#### escape、encodeURI、encodeURIComponent的区别？

encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。

encodeURI 是将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。

escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外的字符的处理有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 会先将字符转换为 UTF-8 的格式，再在每个字节前加上 %。



#### 预加载和懒加载的区别？

预加载是指在页面加载完成之前，提前将所需资源下载，之后使用的时候从缓存中调用；

懒加载是延迟加载，按照一定的条件或者需求，等到满足条件的时候再加载对应的资源；

两者主要区别是，一个是提前加载，一个是迟缓甚至不加载；懒加载对服务器有一定的缓解压力作用，预加载则会增加服务器压力。



#### 如何进行性能优化或减少页面加载时间的方式？

静态资源优化：
①选择更合理的图像格式，如GIF提供的颜色较少，可用在一些对颜色要求不高的地方。
②如果图片为css图片，可以使用CSSsprite精灵图，SVGsprite，Iconfont、Base64等技术。
③如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
④如果图片展示区域小于图片的真实大小，则可以在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
⑤minify / gzip 压缩，webP。

交互优化：
①图片懒加载（lazyLoad），在图片未可视区域加一个滚动条事件，判断图片位置与浏览器顶端的距离、页面的距离，如果前者小于后者，则加载。
②使用图片预加载技术，将当前展示图片的前一张和后一张优先下载，如幻灯片、相册等场景。
③标明高度和宽度（如果浏览器没有找到这两个参数，则需要一边下载图片一边计算大小；如果图片很多，浏览器就需要不断地调整页面，这不但影响速度，也影响浏览体验），当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容，从而页面的加载时间变快，浏览体验也会更好。
④缓存：利用HTTP协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。

构建优化：
①服务端渲染。
②动态导入模块。
③预编译。

渲染过程优化：
①HTML 文档结构层次尽量少，最好不深于 6 层。
②脚本尽量放后边，避免阻止页面加载。
③少量首屏样式可以放在标签内。
④样式结构层次尽量简单。
⑤脚本减少 DOM 操作，减少回流，尽量缓存访问 DOM 的样式信息。
⑥尽量减少 JS 修改样式，可以通过修改 class 名的方式解决。
⑦减少 DOM 查找，缓存 DOM 查找结果。
⑧页面滚动时出现的动画或动画在屏幕外，尽量停止。

其它：
①加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。
②降低请求量，减少 HTTP 请求数。
③pipeline。
④使用位运算代替一些简单的四则运算。
⑤避免使用过深的嵌套循环。
⑥不要使用未定义的变量。
⑦当需要多次访问数组长度时，可以用变量保存起来，避免每次都进行属性查找。





### Vue

#### vue-cli的作用是什么？

①.vue 文件转为.js 文件；②ES6 语法转为ES5 语法；③Sass,Less,Stylus语法转为CSS语法；④对jpg、png、font等静态资源的处理；⑤热更新；⑥定义环境变量，区分 dev 和 production 模式；



#### 如何理解Vue或Vue的核心是什么？

Vue 是一套构建用户界面的渐进式的自底向上的增量开发的 MVVM 框架，vue 的核心只关注视图层（即为了解决数据的绑定问题），它的目标是通过 API 实现响应数据绑定和视图更新。

核心思想：数据驱动（视图的内容随着数据的改变而改变）；组件化（可以增加代码的复用性，可维护性，可测试性，提高开发效率，方便重复使用，体现了高内聚低耦合）。

MVVM 思想是 模型 视图，vm 是 v 和 m 连接的桥梁，当模型层数据修改时，VM会检测到，并通知视图层进行相应的修改。



#### MVVM与MVC的区别是什么？

MVC是模型视图控制器，视图是可以直接访问模型，所以视图里面会包含模型信息，mvc 关注的是模型不变，所以在 mvc 中，模型不依赖视图，但是视图依赖模型。

MVVM是模型视图 和 VM，VM是作为模型和视图的桥梁，当模型层数据改变，vm 会检测到，并通知视图层进行相应的修改。



#### 怎么理解MVVM？

MVVM 模式，即 Model-View-ViewModel 模式。

Model 层：对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。

View 层：作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是数据绑定的声明、 指令的声明、 事件绑定的声明。

ViewModel 层：把 View 需要的层数据暴露，并对 View 层的声明负责，即处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听，当 ViewModel
中数据变化，View 层会得到更新。而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化，一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。

优点：
①分离视图（View）和模型（Model），降低代码耦合，提高视图或逻辑的重用性。如视图（View）可以独立于Model变化和修改、一个ViewModel可以绑定不同的"View"上、当View变化的时候Model不可以不变、当Model变化的时候View也可以不变。
②提高可测试性。ViewModel的存在可以帮助开发者更好地编写测试代码。
③自动更新dom：利用双向绑定，数据更新后视图自动更新。

缺点：
①Bug很难被调试。因为使用双向绑定的模式，当界面异常了，有可能是View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。
②一个大的模块中model会很大，虽然使用方便，也能保证数据的一致性，但长期持有且不释放内存就会花费更多的内存。
③对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。



#### 如何理解vue的单向数据流？

父级 prop 的更新会向下流动到子组件中，每次父组件发生更新，子组件的所有的 prop 都会刷新为最新的值；

数据从父组件传递给子组件，只能单向绑定，子组件内部不能直接修改父组件传递过来的数据。



#### Vue双向绑定的原理？

Vue 双向绑定就是：数据变化更新视图，视图变化更新数据。

Vue 数据双向绑定是通过数据劫持和观察者模式来实现的。数据劫持，即`object.defineproperty`，它的目的是，当给属性赋值的时候，程序会感知到，并控制改变属性值。观察者模式，即当属性发生改变的时候，使用该数据的地方也发生改变。

mvvm双向绑定，采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

要点：
①实现一个数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者；
②实现一个指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数；
③实现一个 Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图；
④mvvm 入口函数，整合以上三者。



#### 如何理解Vue的响应式系统？

响应式系统简述：
任何一个 Vue Component 都有一个与之对应的 Watcher 实例；
Vue 的 data 上的属性会被添加 getter 和 setter 属性；
当 Vue Component render 函数被执行的时候，data 上会被触碰（touch），即被读，getter 方法会被调用，此时 Vue 会去记录此 Vue component 所依赖的所有data（这一过程被称为依赖收集）；
当data 被改动时（主要是用户操作），即被写，setter 方法会被调用，此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。



#### 请简述虚拟dom与diff算法？

虚拟DOM，也就是常说的虚拟节点，本质上是JavaScript对象，是对真实DOM的抽象，相当于在 js 和真实 dom 中间加了一个缓存。它是通过js的object对象模拟DOM中的节点，然后再通过特定的渲染方法将其渲染成真实的 DOM 节点。当状态变更时，记录新树和旧树的差异，最后把差异更新到真正的dom中。

Diff 算法：把树形结构按照层级分解，只比较同级元素，且如果给列表结构的每个单元添加唯一的 key 值，则方便比较。利用diff算法，避免了没有必要的 dom 操作，能避免频繁的操作 DOM，进而避免了大量造成页面的重绘和回流，从而提高了性能，也无需手动操作DOM，极大提高了开发效率。

缺点：在一些性能要求极高的应用中，虚拟DOM无法进行针对性的极致优化。



#### 为什么Vue需要虚拟DOM进行diff检测差异？

既然Vue通过数据劫持可以精准探测数据变化，为什么还要虚拟DOM（push操作？）进行diff检测（pull操作？）差异？现代前端框架有两种方式侦测变化，一种是pull，一种是push。

pull：其代表为React，通常会用 setState API显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道有变化了，然后再进行比较暴力的Diff操作（涉及到所有组件？），查找哪发生变化了。另外一个代表就是Angular的脏检查操作。

push：Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此Vue是一开始就知道是在哪发生变化了。但是这又会产生一个问题，通常绑定一个数据就需要一个Watcher，绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此Vue的设计是选择中等细粒度的方案，在组件级别进行push侦测的方式，即响应式系统。通常会第一时间侦测到发生变化的组件，然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。此在push的阶段并不需要手动控制diff，而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的，但是通常合理大小的组件不会有过量的diff，手动优化的价值有限，因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期。



#### Vue循环的key的作用？

key 值的存在保证了唯一性，默认用“就地复用”策略。

在Vue的diff函数中，当进行交叉对比时，会对节点进行检查。

①如果有 key 值存在，那么会对新老节点进行对比，如果新节点跟旧节点头尾交叉对比没有结果，就会根据新节点的key去对比旧节点数组中的 key，寻找相应旧节点（这里对应的是一个key => index 的map映射）。如果找到了，则过比较两者 key是否相同，简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，从而进行调换位置或删除操作；如果没找到就认为是一个新增节点。通key 的作用主要是为了高效地更新虚拟DOM。

②如果没有 key 值，那么 vue 检查到这里有 dom 节点，在需要更新时，就会对内容清空并赋新值；



#### 如何理解proxy？

vue 的数据劫持有两个缺点：
①无法监听通过索引修改数组的值的变化；
②无法监听object，也就是对象的（新增的？）值的变化，只能针对单例属性做监听，只能对 data 中预定义过的属性做出响应，所以 vue2.x 中才会有$set 属性的存在。

proxy 是 es6 中推出的新 api，可以弥补以上两个缺点，所以 vue3.x版本用 proxy 替换 object.defineproperty。Vue3.0是如何变得更快的？

①diff 方法优化。Vue2.x 中的虚拟 dom 是进行全量的对比。而Vue3.0 中新增了静态标记（PatchFlag），在与上次虚拟结点进行对比的时候，值对比带有 patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。

②hoistStatic 静态提升。Vue2.x，无论元素是否参与更新，每次都会重新创建（非sameVnode）；Vue3.0，对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用。

③响应式是惰性的，会按需实现响应式，减少性能消耗。Vue2.x，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就要重新递归遍历对象，把每一层对象数据都变成响应式的；Vue3.0，因为proxy不能监听到对象内部深层次的属性变化，它的处理方式是在 getter 中去递归响应式，这样做的好处是只有真正访问到的内部属性才会变成响应式。

④cacheHandlers 事件处理器缓存。默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化，但是因为是同一个函数，所以没有必要追踪变化，所以在Vue3.0里直接缓存起来复用即可。

优点：Proxy可以直接监听对象而非属性，这个对象的所有操作都会进入监听操作，这就完全可以代理所有属性；Proxy可以直接监听数组的变化；Proxy有多达13种拦截方法，且如apply、ownKeys、deleteProperty、has等是Object.defineProperty所不具备的；Proxy返回的是一个新对象，可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改；Proxy作为新标准将受到浏览器厂商重点持续的性能优化。



#### Vue数据绑定有哪些方式？

①单向绑定，用双大括号{{}}的形式

②v-bind 绑定，用于html的属性绑定

③双向绑定，用v-model

④一次性绑定，用v-once



#### Vue组件中的data为什么是函数？

Data 是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。

否则，如果是引用类型（对象）的话，当多个组件共用一个数据源时，一处数据改变，所有的组件数据都会改变，所以要利用函数通过 return 返回对象的拷贝（返回一个新数据），让每个实例都有自己的作用域，相互不影响。



#### vue中怎么重置data？

使用Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data(this)可以获取到组件 初始化状态下的data。

可使用`Object.assign(this.$data, this.$options.data(this))`。vm.$data可以获取当前状态下的data；vm.$options.data(this)可以获取到组件 初始化状态下的data，注意加this，不然取不到data函数中的 `a: this.methodA` 里的 `this.methodA`。



#### 请简述Vue的生命周期？

Vue生命周期的作用是给了用户在不同阶段添加自己的代码的机会。vue 的生命周期就是 vue 实例创建到实例销毁的过程。期间会有 8 个钩子函数的调用：

beforeCreate（创建实例）、created（创建完成）、beforeMount（开始创建模板）、mounted（创建模板完成）、beforeUpdate（开始更新）、updated（更新完成）、beforeDestroy（开始销毁）、destroyed（销毁完成）。此外还有 activated 和 deactivated。



#### 如何理解keep-alive？

概念：keep-alive 是 vue 的内置组件，当它动态包裹组件时，会缓存不活动的组件实例，它自身不会渲染成一个 DOM 元素也不会出现在父组件链中。

作用：在组件切换过程中，将组件的状态保留在内存中，防止重复渲染 DOM，减少加载时间以及性能消耗，提高用户体验。

生命周期函数：activated在 keep-alive 组件激活时调用，deactivated在 keep-alive 组件停用时调用。



#### 异步请求适合在哪个生命周期调用？

官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用。

`created`钩子函数在实例创建之后、挂载之前被调用，此时还没有挂载到DOM上，适合做一些不依赖于DOM的操作，比如数据请求。

`mounted`钩子函数在实例挂载到DOM上之后被调用，此时已经完成了DOM的渲染，适合做一些依赖于DOM的操作，比如初始化组件内的某些DOM元素。



#### 组件中写 name 选项有什么作用？

①项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤；

②做递归组件时的DOM，需要调用自身 name；

③在vue-devtools调试工具里显示的组件名称是由vue中组件name决定的；



#### Vue常用的修饰符有哪些？

作用修饰符：

.lazy 改变后触发，光标离开 input 输入框的时候值才会改变；

.number 将输出字符串转为 number 类型；

.trim 自动过滤用户输入的首尾空格；

事件修饰符：

.stop 阻止点击事件冒泡，相当于原生 js 中的 event.stopPropagation()；

.prevent 防止执行预设的行，相当于原生 js 中event.preventDefault()；

.capture 添加事件侦听器时使用事件捕获模式，就是谁有该事件修饰符，就先触发谁；

.self 只会触发自己范围内的事件，不包括子元素；

.once 只执行一次；

键盘修饰符：.enter 回车键；.tab 制表键；.esc 返回键；.space 空格键；.up 向上键；.down 向下键；.left 向左建；.right 向右键；

系统修饰符：.ctrl .alt .shift .meta。



#### Vue中的指令有哪些？

v-for：用于循环数组、对象、字符串、数字

v-on：绑定事件监听

v-bind：动态绑定一个或者多个属性

v-model：表单控件或者组件上创建双向绑定

v-if v-else v-else-if：条件渲染

v-show：根据表达式真假，切换元素的 display

v-html：更新元素的 innerhtml

v-text：更新元素的 textcontent

v-pre：跳过这个元素和子元素的编译过程

v-clock：这个指令保持在元素上直到关联实例结束编译

v-once：只渲染一次



#### v-on可以绑定多个方法吗？

可以，如果绑定多个不同类型的事件，可以用键值对的形式，即事件类型：事件名。如果绑定是多个相同类型事件，直接用逗号分隔就行。

```html
<button v-on='{click:a,mouseleave:b}'>绑定多个不同类型事件</button>
<button @click="a(),b()">绑定多个相同类型事件</button>
```



#### v-text与{{}}与v-html的区别？

v-text 将数据解析为纯文本，不能输出真正的 html，在页面加载时也不会显示双花括号

{{}} 将数据解析为纯文本，不能显示输出 html，在渲染的数据比较多的时候，可能会把大括号显示出来（屏幕闪动）

v-html 可以渲染输出 html



#### v-for与v-if的优先级如何？

v-for 比 v-if 具有更高的优先级。

另外要注意不要把 v-if 与 v-for 用在同一个元素上，因为v-for 比 v-if 优先。如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。



#### Vue中的组件之间怎么通信？

父传子：父组件把要传递的数据绑定在属性上，子组件通过props接收。

子传父：子组件通过 this.$emit(自定义事件名，要发送的数据)，父组件设置一个监听事件来接收，然后拿到数据。

兄弟组件通信：通过eventbus中央事件总线。

全局数据共享方案：通过 Vuex。

其它方案： 
$attrs/$listeners（可以进行跨级的组件通信）、 
provide/inject（允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在上下游关系成立的时间里始终生效，这成为了跨组件通信的基础）、 
$parent/$children、
ref（获取组件实例）、
slot（插槽）。



#### 计算属性与侦听器的区别？

区别：

computed是用来声明式地描述一个值依赖了其它的值，自动监听依赖值的变化，当所依赖的值后者变量发生变化时，计算属性也跟着改变，从而动态返回内容，主要目的是简化模板内的复杂运算。computed可以依赖其它computed，甚至是其它组件的data。每个计算属性都包括一个 getter 和 setter，读取时触发 getter，修改时触发 setter。computed具有缓存功能，当无关数据数据改变时，不会重新计算，而是直接使用缓存中的值。

watch为了监听某个响应数据的变化，监听的是在 data 中定义的变量，当该变量变化时，会触发watch中的方法。

区别来源于用法，如果只是需要动态值，那就用 computed，如果需要知道值的改变后执行业务逻辑，就用 watch，如果是既能用computed实现又能用watch实现的功能，则推荐用computed。



#### Vue的nextTick的原理是什么？

Vue 是异步修改 DOM 的，且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改和刷新后的 DOM 做相应的处理，这时候就可以使用`Vue.nextTick(callback)`这个api。注意这个是微任务。

nextTick 的原理是 vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。这部分的源码做了很多 isNative()的判断，因为这里还存在兼容性优雅降级的问题。



#### 删除数组用delete和Vue.delete的区别？

delete只是将被删除的数组成员变为empty/undefined（其它元素键值不变）。

Vue.delete是直接删了数组成员，并改变了数组的键值（对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开Vue不能检测到属性被删除的限制）。



#### Vue单页面的优缺点？

优点：前后端分离；用户体验好；内容改变不需要重新加载整个页面；数据驱动视图；响应式（通过MVVM思想实现数据的双向绑定）；组件化（方便重复使用，使项目的可维护性更强）；提供一系列api满足业务开发中的各类需求；生态好，社区活跃。

缺点：不利于 seo；初次加载时耗长（浏览器一开始就要加载 html css js ，所有的页面内容都包含在主页面中），页面复杂度提高了；Object.defineProperty这个api在IE8及以下浏览器不支持。



#### 如何解决Vue首屏加载慢？

首屏加载慢的原因：第一次加载页面时，有很多组件数据需要渲染。

解决方法：

①把不常改变的库（如vue、vue-router、element-ui等）放到 index.html 中，通过 cdn 引入，并在 `build/webpack.base.conf.js` 文件里的externals对象里添加相应的库，这样 webpack 就不会把这些库打包了。

②路由懒加载，使用import或require，如component: () => import(“路由地址”)。

③不生成 map 文件，在`config/index.js`文件里修改productionSourceMap为false。

④vue 组件尽量不要全局引入。

⑤使用更轻量级的工具库。

⑥gzip压缩，如前端将文件打包成.gz文件，然后通过nginx的配置，让浏览器直接解析.gz文件。

⑦ui框架按需加载。

⑧首页单独做服务端渲染。

解决白屏问题：

①使用 v-text 渲染数据。

②使用{{}}语法渲染数据，但是同时使用 v-cloak 指令（用来保持在元素上直到关联实例结束时候进行编译），注意v-cloak 并不需要添加到每个标签，只要在 el 挂载的标签上添加就可以。



#### route与router有什么区别？

router 是“路由实例对象”，是 VueRouter 的一个对象，通过 Vue.use(VueRouter)和VueRouter 构造函数得到一个 router 的实例对象，这个对象是一个全局的对象，它包含了所有的路由，还包含了许多关键的对象和属性，也包括路由的跳转方法（push 、replace）和钩子函数等。

route 是“路由信息对象”，是一个跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部的对象，包括 path、params、hash、query、fullPath、matched、name等路由信息参数。



#### Vue中路由跳转方式有哪些？

Vue 中路由跳转有两种，分别是声明式和编程式。

用 js 方式进行跳转的叫编程式导航，如this.$router.push()。用 router-link 进行跳转的叫声明式导航，且router-view为路由出口。

在 router-link 中使用 name 可导航到对应路由，使用 name 导航的同时，可给子路由传递参数。



#### vue-router有哪些钩子函数？

①全局前置守卫router.beforeEach；②全局解析守卫router.beforeResolve；③全局后置钩子router.afterEach；④路由独享的守卫beforeEnter；⑤组件内的守卫beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。



#### Vue路由传参的两种方式（params和query）的区别？

动态路由也可以叫路由传参，就是根据不同的选择在同一个组件渲染不同的内容。

用法上：query 用 path 引入，params 用 name 引入，接收参数都是类似的，分别是 this.$route.query.xxxname 和 this.$route.params.xxxname；

url 展示上：params 类似于 post，query 类似于 get，也就是安全问题，params 传值相对更安全点，query 通过 url 传参，刷新页面还在，params刷新页面不在了；



#### 如何理解Vuex？

Vuex 是一个专为 vue.js 应用程序开发的状态管理模式，通过创建一个集中的数据存储，方便程序中的所有组件进行访问。 vuex 就是vue 的状态管理工具。

优点：解决了非父子组件的通信，减少了 ajax 请求次数，有些可以直接从 state 中获取；缺点：刷新浏览器，vuex 中的 state 会重新变为初始状态。

Vuex 有五个属性state、getters、mutations、actions、modules。

state 就是数据源存放地，对应一般 vue 对象的 data，state 里面存放的数据是响应式的，state 数据发生改变，对应这个数据的组件也会发生改变，用 this.$store.state.xxx 调用，也可以通过 mapstate 把全局的 state 和 getters 映射到当前组件的计算属性中。

getters 可以对 state 进行计算操作，相当于 store 的计算属性，主要是对 state 中数据的过滤，用this.$store.getters.xxx 调用，也可以在多组件之间复用，但如果一个状态只在一个组件内使用，可以不用 getters。

mutations 表示处理数据逻辑的方法全部放在 mutations 中，当触发事件想改变 state 数据的时候使用 mutations，且更改状态的唯一办法就是提交 mutation，用 this.$store.commit 调用，也可以在回调函数中修改 store 中的状态。

actions 可以包含任意异步操作，但是变更状态还是要通过 mutation 来操作，用this.$store.dispatch 来触发。

使用场景：组件之间的状态，如登录状态、加入购物车等等。

Vuex 使用流程：

①下载 vuex

②在 src 下创建 store目录以及创建index.js文件

③引入 vue 和 vuex， 使用 vuex ，导出实例对象

④在 main.js 中引入，在.vue 文件中使用



#### 如何理解组件？

可组合，可复用，可维护，可测试。



#### Elementui中的常用组件有哪些？

Container 布局容器

<el-container>外层容器

<el-header>顶栏容器

<el-aside>侧边栏容器

<el-main>主要内容容器

<el-footer>底栏容器

Dropdown 下拉菜单

<el-container split-buton> 下拉按钮

<el-container-menu> 下拉菜单

<el-container-item> 下拉项

Table 表格

Tabs 标签页

Form 表单

Pagination 分页

Message 消息提示

<el-alert>弹窗</el-alert>

<el-dialog>对话</el-dialog>

<el-calender>日历表</el-calender>

<el-progress :percentage="0">进度条<el-progrees>

<el-switch>开关</el-switch>





### React

#### 如何理解react？

React 起源于 facebook，react 是一个用于构建用户界面的 js 库。

特点：

①声明式设计：react 采用范式声明，开发者只需要声明显示内容，react就会自动完成；

②高效：react 通过对 dom 的模拟（也就是虚拟 dom），最大限度地减少与 dom 的交互；

③灵活：react 可以和已知的库或框架很好地配合；

④组件：把页面功能拆分成小模块，每个小模块就是组件，通过 react 构建组件，让代码更容易复用，能够很好地应用在大型项目开发中；

⑤单向数据流：react 是单向数据流，数据通过 props 从父节点传递到子节点，如果父级的某个 props 改变了，react 会重新渲染所有的子节点；



#### react生命周期函数有哪些？

componentWillMount 组件渲染之前调用。

componentDidMount 在第一次渲染之后调用。

componentWillReceiveProps 在组件接收到一个新的 props（属性）时调用。

shouldComponentUpdate 判断组件是否更新 html。

componentWillupdate 组件即将更新 html 时调用。

componentDidupdate 在组件完成更新后立即调用。

componentWillUnmount 在组件移除之前调用。



#### React事件处理如何修改this指向？

①通过 bind 方法进行原地绑定，从而改变 this 指向

②通过创建箭头函数

③在 constructor 中提前对事件进行绑定

④将事件调用的写法改为箭头函数的形式



#### setState在什么情况下是同步或异步的？

在React的setState函数实现中，会根据一个变量isBatchingUpdates进行判断，是直接更新this.state，还是放到队列中。

①如果是绕过React，且通过addEventListener直接添加的事件处理函数，或通过setTimeout、setInterval产生的异步调用，则会同步执行this.state。因为isBatchingUpdates默认是false，表示setState会同步更新this.state。

②如果是由React引发的事件处理（如通过onClick引发的事件处理），则调用setState不会同步更新this.state。因为React在调用事件处理函数之前就会调用batchedUpdates函数，这个函数会把isBatchingUpdates修改为true，造成React控制的事件处理过程setState不会同步更新this.state。



#### 调用setState之后发生了什么？

React 在调用 setState 后，react 会将传入的参数对象和组件当前的状态进行合并，触发调和过程。在调和过程中，react 会根据新的状态构建 react 元素树，重新渲染整个UI 界面，在得到元素树之后，react 会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染。



#### 应该在React组件的何处发起Ajax请求？

在 React 组件中，应该在 componentDidMount 中发起网络请求，这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。

因为你不能保证在组件挂载之前，Ajax 请求就已经完成，如果在组件挂载之前的生命周期钩子函数里发请求，也就意味着将尝试在一个未挂载的组件上调用 setState，这将不起作用。

在 componentDidMount 中发起网络请求，将保证这该组件可以满足条件更新了。



#### 什么是高阶组件？

高阶组件是一个以组件为参数并返回一个新组件的函数。

HOC 运行重用代码、逻辑和引导抽象，最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果发现在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的HOC。



#### 展示组件和容器组件的区别？

React组件根据组件的职责，通常分为展示组件（UI组件）和容器组件。展示组件负责UI的呈现，容器组件负责管理数据和逻辑。两者通过 React-Redux 提供 connect 方法联系起来。

展示组件（Presentational component）关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但如果展示组件拥有自身的状态时，通常也只关心UI状态而不是数据的状态。

容器组件（Container component）则更关心组件是如何运作的。容器组件会为展示组件或其它容器组件提供数据和行为（behavior），它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是（其它组件的）数据源。



#### 状态(state)和属性(props)之间有何不同？

state 与 props 的区别：

props 是一个从外部传进组件的参数，主要作用就是父组件向子组件传递数据，但是 props 对于使用它的组件来说是只读的，一旦赋值不能修改，只能通过外部组件主动传入新的 props 来重新渲染子组件。

state 是一个组件的显示形态，可以由数据状态和外部参数决定，外部参数是props，数据状态就是 state，首先，在组件初始化的时候，用 this.state给组件设定一个初始的 state，在第一次渲染的时候就会用这个数据来渲染组件，用于组件挂载时所需数据的默认值。state可能会随着时间的推移而发生突变，可以通过 this.setState()方法来修改 state，但多数时候是作为用户事件行为的结果。



#### redux的缺点？

①一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从store 取。

②当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会影响效率，或需要写复杂的 shouldComponentUpdate 进行判断。



#### Vue与React的异同？

相同点：

①都支持服务器渲染；

②都有虚拟 dom，组件化开发，通过 props 参数进行父子组件数据的传递；

③都实现 webcomponent 规范；

④都是数据驱动视图；

⑤都有状态管理，react 有 redux，vue 有 vuex；

⑥都有支持native的方案，react 有 react native，vue 有 weex；

不同点：

①react 严格上只针对 mvc 的 view 层，vue 是 mvvm 模式；

②虚拟 dom 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个 dom 组件树，而 react 不同，当应用的状态被改变时，全部组件都会重新渲染，所以 react 中用 shouldcomponentupdate 这个生命周期的钩子函数来控制组件；

③写法不一样 ，react 是 jsx 和 inline style ，就是把 html 和 css 全写进 js 中，vue 则是 html、css、js 在同一个文件里面；

④数据绑定不一样，vue 实现了数据双向绑定，react 数据流动是单向的，另外，在 react 中，state 对象需要用 setstate 方法更新状态，而在 vue 中，state对象不是必须的，数据由 data 属性进行管理；



#### 对Vue和React做一个对比？

①监听数据变化的实现原理不同。

Vue 通过 getter/setter 以及一些函数的劫持，能精确快速的计算出 Virtual DOM 的差异。这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。

React 默认是通过比较引用的方式进行的，如果不优化，每当应用的状态被改变时，全部子组件都会重新渲染，可能导致大量不必要的 VDOM 的重新渲染。

Vue 不需要特别的优化就能达到很好的性能，而对于 React 而言，需要通过PureComponent/shouldComponentUpdate这个生命周期方法来进行控制。如果应用中交互复杂，需要处理大量的 UI 变化，那么使用 Virtual DOM 是一个好主意；如果更新元素并不频繁，那么Virtual DOM 并不一定适用，性能很可能还不如直接操控 DOM。

为什么 React 不精确监听数据变化呢？这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而 React 更强调数据的不可变。

②数据流的不同。

Vue 中默认支持双向绑定，组件与 DOM 之间可以通过 v-model 双向绑定。但是，父子组件之间，props 在 Vue2.x 版本是单向数据流。

React 一直提倡的是单向数据流，称之为 onChange/setState()模式。

③模板渲染方式的不同。

在表层上，模板的语法不同。React 是通过 JSX 渲染模板，而 Vue 是通过一种拓展的 HTML 语法进行渲染

在深层上，模板的原理不同，这才是本质区别。React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，如插值、条件、循环等，都是通过 JS 语法实现的；而 Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，如条件语句需要 v-if 来实现。









### 其它库

#### 小程序有哪些优势？

无需下载安装，直接使用，运行速度快，项目搭建迅速，短小精悍，每个 app 源代码不超过 2mb。



#### 小程序的页面由哪些文件构成？

Index.js index.json index.wxml index.wxss。



#### 小程序的生命周期钩子函数有哪些？

onload、onready、onshow、onhide、onunload、onpulldownrefresh 、onreachbottom 、onshareappmessage。



#### 如何提高小程序的首屏加载时间？

①提前请求：异步数据请求不需要等待页面渲染完成；

②利用缓存：利用 storage API 对异步请求数据进行缓存，二次启动时，先利用缓存数据渲染页面，再进行后台更新；

③避免白屏：先展示页面骨架和基础内容；

④及时反馈：及时地对需要用户等待的交互操作给出反馈，避免用户以为小程序没有响应；

⑤性能优化：避免不当使用 setdata 和 onpagescroll；



#### 有哪些小程序的组件是经常使用的？

view icon text image swiper navigator input button map



#### 请简述webpack中的loader与plugin的区别？

loader是文件加载器，是一个转换器，能够加载资源文件，只专注于转换文件这一个领域，并对这些文件进行处理（如编译和压缩等），最终一起打包到指定文件中，仅仅是为了打包，并且运行在打包之前。

plugin 是扩展 webpack 功能的，是一个扩展器，在 webpack 运行的生命周期会有许多事件，plugin可以监听这些事件，通过 plugin，webpack 可以实现 loader 不能完成的复杂功能，不局限于打包和资源的加载，还有其它的功能，在整个编译周期都起作用。

区别：loader是用来加载文件的，webpack 本身只能加载 js 文件(内置 babel-loader)，加载其它文件就需要安装别的 loader，如css-loader、file-loader等。



#### webpack的几种hash的实现原理？

①hash 是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的 hash 值都会更改，并且全部文件都共用相同的 hash 值。（粒度整个项目）

②chunkhash 是根据不同的入口进行依赖文件解析，构建对应的chunk（模块），生成对应的hash值。同一个 chunk 下的文件有所改动，则该 chunk 下的文件的 hash 值就会发生改变，且只有被修改的chunk（模块）在重新构建之后才会生成新的 hash 值，不会影响其它的 chunk 。（粒度entry的每个入口文件）

③contenthash 是跟每个生成的文件有关，每个文件都有一个唯一的 hash 值。当要构建的文件内容发生改变时，就会给该文件生成生成新的 hash 值，且该文件的改变并不会影响和它同一个模块下的其它文件。（粒度每个文件的内容）



#### webpack是如何处理图片的？

在 webpack 中有两种处理图片的loader。

file-loader ：解决 CSS 等中引入图片的路径问题（解决通过`url`、`import/require()`等引入图片的问题）。
url-loader ：当图片小于设置的 limit 参数值时，url-loader 将图片进行 base64 编码（当项目中有很多图片，通过 url-loader 进行 base64 编码后会减少 http 请求数量，提高性能），大于limit参数值，则使用 file-loader 拷贝图片并输出到编译目录中。



#### echarts 使用最多的是什么？

图表及图表组合。



#### ajax和axios和fetch的区别是什么？

传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始 js 中，核心使用 XMLHttpRequest 对象，但是多个请求之间如果有先后关系的话，就会出现回调地狱。另外，JQuery里的ajax 是对原生XHR 的封装。

axios 是一个基于 Promise ，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，符合最新的 ES 规范。

fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest对象。fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功，因为用fetch的post请求的时候，导致fetch第一次发送了一个Options请求（不是跨域的预检？），询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。



#### JSON 的了解？

JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集，数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如，`{'age':'12', 'name':'back'}`。



#### 大公司和小公司开发的区别？

大型外包公司更加流程化，人员多，沟通少，项目交付后不需要自己维护，采用瀑布开发模式（以文档为主）；

小型公司：人少，需求经常改变，沟通方便，采用敏捷开发（快速推出v1 版本 ，之后迭代）。





### Node

#### 如何进行模块化开发？

一个模块是实现一个特定功能的一组方法。

在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。

由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。

后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。

现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。



#### JS的模块加载方案有哪些？

js 中现在比较成熟的有四种模块加载方案。

①CommonJS 方案（服务器端的解决方案）：通过 module.exports 定义模块的输出接口，通过 require 来引入模块，并以同步的方式来引入模块，因为在服务端文件都存储在本地磁盘，所以读取非常快。但如果是在浏览器端，由于模块的加载使用网络请求，因此使用异步加载的方式更加合适。

②AMD 方案：AMD 推崇依赖前置。require.js 实现了 AMD 规范，核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。

③CMD 方案：CMD 推崇就近依赖。sea.js 实现了 CMD 规范。跟 AMD 方案相似都是为了解决异步模块加载的问题，和 require.js 的区别在于模块定义时，对依赖的处理不同和对依赖模块的执行时机的处理不同。

④ES6 提出的方案：使用 import 和 export 的形式来导入导出模块。



#### CommonJS模块与ES6模块的区别？

CommonJS 模块输出的是一个值的拷贝，即一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的是值的引用，即JS引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里面去取值，被输出模块的内部的改变会影响引用的改变。

CommonJS 模块是运行时加载，是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法；ES6 模块是编译时输出接口，不是对象（而是对象的引用？），它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

CommonJs导入的模块路径可以是一个表达式，因为它使用的是 require() 方法，而ES6 Modules只能是字符串；

CommonJS的this指向当前模块，而ES6 Modules的this指向undefined，且没有一些顶层变量（arguments、require、module、exports、\_\_filename、\_\_dirname）。



#### npm模块安装机制？

①发出 npm install 命令。

②查询node_modules目录之中是否已经存在指定模块，若存在则不再重新安装，若不存在，则npm先向 registry 查询模块压缩包的网址，再下载压缩包并存放在根目录下的 .npm 目录里，最后解压压缩包到当前项目的 node_modules 目录下。





### Git

#### rebase与merge的区别？

`git rebase`和`git merge`一样都是用于从一个分支获取并合并到当前分支。

merge特点：自动创建一个新的 commit，如果合并的时候遇到冲突，仅需要修改后重新 commit。
优点：记录了真实的 commit 情况，包括每个分支的详情。
缺点：因为每次 merge 会自动产生一个 merge commit，所以在使用一些git的GUI tools时，如果commit比较频繁，则会看到分支很杂乱。

rebase特点：会合并之前的 commit 历史。
优点：得到更简洁的项目历史，去掉了merge的commit。
缺点：如果合并出现代码问题，则不容易定位，因为re-write了history。

因此，当需要保留详细的合并信息的时候建议使用`git merge`（特别是需要将分支合并进入master分支时），当修改某个功能，并频繁进行了commit提交，且过多的提交信息没有必要时，可以尝试`git rebase`。







### 计算机网络

#### TCP和UDP的区别？

①TCP 是面向连接的可靠性传输；UDP是无连接的，即发送数据前不需要先建立链接，且是不可靠的。

②TCP 提供可靠的服务，即通过 TCP 连接传送的数据无差错、不丢失、不重复、按序到达，适合大数据量的交换；UDP 尽最大努力交付，不保证可靠交付。

③TCP 是面向字节流；UDP 面向报文，并且网络出现拥塞后不会使得发送速率降低，因此会出现丢包，可用于实时的应用（如 IP 电话和视频会议等）。

④TCP 只能是1对1的；UDP 支持1对1和1对多。

⑤TCP 的首部较大，为 20 字节；而UDP 只有 8 字节。



#### 什么是http及其特点？

http叫做超文本传输协议，是互联网应用最广泛的一种网络协议。

特点：基于请求-响应的模式。



#### HTTP协议和HTTPS区别？

**HTTP1.1 是当前使用最为广泛的HTTP协议。HTTP1.1 和 HTTP1.0 相比：**

①HTTP1.0 定义了三种请求方法（GET, POST 和 HEAD 方法），HTTP1.1 新增了六种请求方法（OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法）。

②缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。

③带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，如客户端只需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，而HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

④错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除。

⑤Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，所以请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

⑥长连接：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启`Connection： keep-alive`，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。通过设置http的请求头部和应答头部，保证本次数据请求结束之后，下一次请求仍可以重用这一通道，避免重新握手。

**HTTP2.0 和 HTTP1.x 相比：**

①新的二进制格式（Binary Format）：HTTP1.x的解析是基于文本。而基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

②多路复用（MultiPlexing）：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id，将request再归属到各自不同的服务端请求里面。

③header压缩：HTTP1.x的header带有大量信息，且每次都要重复发送。HTTP2.0使用了专门为首部压缩而设计的 HPACK 算法，使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

④服务端推送（server push）：服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为减少了发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。如网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件也推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。

**HTTPS介绍：**

HTTPS在传输数据之前需要客户端（浏览器）与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了非对称加密、对称加密以及HASH算法。握手过程：

①浏览器将自己支持的一套加密规则发送给网站（服务端）。

②网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含网站地址、加密公钥、证书的颁发机构等信息。

③浏览器获得网站证书之后要做：验证证书的合法性（颁发证书的机构是否合法、证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示；如果证书受信任，或用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密；使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

④网站接收浏览器发来的数据之后要做：使用自己的私钥将信息解密，取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致；使用密码加密一段握手消息，发送给浏览器。

⑤浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会保管好自己的私钥以防止泄漏。TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。

**区别：**

①http 是超文本传输协议，信息是明文传输；而https 是具有安全性的 ssl 解密传输协议。

②http 和 https 连接方式完全不同，端口也不同，http 是 80，https 是 443（即https://www.example.com:443/等同https://www.example.com/）。

③http 的连接很简单，是无状态的，HTTP协议运行在TCP之上，所有传输的内容都是明文；https 协议是由 ssl+http 协议构建的，可进行加密传输和进行身份认证的网络协议，运行在SSL/TLS之上，而SSL/TLS运行在TCP之上，所有传输的内容都经过加密的，比 http 协议安全。但SSL证书需要绑定 IP，且不能在同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。

④HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费，功能越强大的证书费用越高。

⑤HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

⑥https 握手阶段比较费时，会使页面加载时间延 50%，增加10%~20%的耗电。

⑦https 缓存比 http 低效，会增加数据开销。



#### 如何把项目中的http请求换成https？

①把项目中对 axios 的每次请求的域名所在的配置文件，修改 baseURL 字段替换前缀为 https。

②利用 meta 标签把 http 请求换为 https，`<meta http-equiv ="Content-Security-Policy" content="upgrade-insecure-requests">`。



#### （常见的）HTTP状态码有哪些？

1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码：
**100 - 继续。**请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果。
101 - 切换协议。请求者已要求服务器切换协议，服务器已确认并准备切换。

2xx（成功）表示成功处理了请求的状态码：
**200 - 成功。**这个是最常见的 http 状态码，服务器已经成功处理了请求。通常这表示服务器提供了请求的网页，并将返回客户端所请求的最终结果，返回的数据为全量的数据。
**201 - 已创建。**请求成功并且服务器创建了新的资源。
**202 - 已接受。**服务器已接受请求，但尚未处理，而且这个请求最终会不会处理还不确定。
203 - 非授权信息。服务器已经成功处理了请求，但返回的信息可能来自另一来源。
204 - 无内容。服务器成功处理了请求，但没有返回任何内容，可能会返回新的头部元信息。
205 - 重置内容。服务器成功处理了请求，但没有返回任何内容。
206 - 部分内容。服务器成功处理了部分GET请求。

3xx（重定向）表示要完成请求，需要进一步操作，通常这些状态代码用来重定向：
300 - 多种选择。针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择。
**301 - 永久移动。**请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置。
**302 - 临时移动。**服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
**303 - 查看其它位置。**请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码。
**304 - 未修改。**自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。
305 - 使用代理。请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。
307 - 临时性重定向。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求。

4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理：
**400 - 错误请求。**服务器不理解请求的语法。
**401 - 未授权。**请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。
**403 - 禁止。**服务器拒绝请求。
**404 - 未找到。**服务器找不到请求的网页。请求失败，客户端请求的资源没有找到或不存在。
405 - 方法禁用。禁用请求中指定的方法。
406 - 不接受。无法使用请求的内容特性响应请求的网页。
407 - 需要代理授权。此状态码与401（未授权）类似，但指定请求者应当授权使用代理。
408 - 请求超时。服务器等候请求时发生超时。
409 - 冲突。服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。
410 - 已删除。如果请求的资源已永久删除，服务器就会返回此响应。
411 - 需要有效长度。服务器不接受不含有效内容长度标头字段的请求。
412 - 未满足前提条件。服务器未满足请求者在请求者设置的其中一个前提条件。
413 - 请求实体过大。服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力。
414 - 请求的URI过长。请求的URI（通常为网址）过长，服务器无法处理。
415 - 不支持媒体类型。请求的格式不受请求页面的支持。
416 - 请求范围不符合要求。如果页面无法提供请求的范围，则服务器会返回此状态码。
417 - 未满足期望值。服务器未满足“期望”请求标头字段的要求。

5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误（这些错误可能是服务器本身的错误，而不是请求出错）：
**500 - 服务器内部错误。**服务器遇到错误，无法完成请求。
501 - 尚未实施。服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
502 - 错误网关。服务器作为网关或代理，从上游服务器无法收到无效响应。
**503 - 服务器不可用。**服务器目前无法使用（由于超载或者停机维护），通常这只是暂时状态。
504 - 网关超时。服务器作为网关代理，但没有及时从上游服务器收到请求。
505 - HTTP版本不受支持。服务器不支持请求中所用的HTTP协议版本。



#### 如何理解get和post？

get 和 post 在请求参数方面的区别：实际上，HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源于浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度，GET 有最大长度显示是因为浏览器和 web 服务器限制了，URI 的长度取决于浏览器和web服务器。在客户端，get 通过 url 提交数据，数据在header中可以看到，比 post 更不安全。post 方式，数据放在body中提交。get 提交数据最多只能有 1024 字节，post 没有限制。GET 只接受 ASCII字符的数据类型的参数，而 POST 没有限制。

get 和 post 在缓存方面的区别：get 请求类似于查找的过程，一般是从服务器上获取数据，如用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存，会被浏览器主动 cache。post则不同，post 做的一般是修改和删除的工作，一般是向服务器传送数据，所以必须与数据库交互，不能使用缓存（除非手动设置）。因此 get 请求适合于请求缓存。

GET 在浏览器回退时是无害的，且请求参数会被完整保留在浏览历史记录里，而 POST 会再次提交请求，且不保留参数。

GET 请求只能进行 url(x-www-form-urlencoded)编码，而 POST 支持多种编码方式。

GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。对于 GET 方式的请求，浏览器会把 http 的 header 和 data 一并发送出去，服务器响应200（返回数据）。而对于 POST，浏览器先发送header，服务器响应100 continue，浏览器再发送 data，服务器再响应200（返回数据）。



### 数据结构和算法

#### 什么是栈和堆？

堆和栈的概念存在于数据结构中和操作系统内存中。

在数据结构中，栈中数据的存取方式为先进后出，而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。

在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值、局部变量的值等。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。





### 浏览器

#### 如何判断当前脚本运行在浏览器还是node环境？

通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中，`this === window ? 'browser' : 'node';`。



#### 怎么检测浏览器版本？

检测浏览器版本一共有两种方式：

①检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，且早期的浏览器（如 ie），会通过伪装 userAgent 的值为 Mozilla 来躲过服务器的检测。
②功能检测，根据每个浏览器独有的特性来进行判断（如 ie 独有的 ActiveXObject）。



#### 怎么理解浏览器内核？

主要分成两部分：渲染引擎（layout engineer或Rendering Engine）和JS引擎。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

不同浏览器的渲染引擎：IE系列的Trident内核、Firefox的Gecko内核、Safari的Webkit内核、Chrome/opera等几乎所有浏览器的Blink内核（基于Webkit内核）、几乎所有国产浏览器（如360、猎豹、qq、百度等）的（Trident/Blink）双内核。

渲染引擎负责取得网页的内容（HTML、XML、图像等）、整理讯息（如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。但是浏览器的内核的不同，对于网页的语法解释会有不同， 所以渲染的效果也不相同。

JS引擎负责解析和执行javascript来实现网页的动态效果。



#### 如何实现浏览器内多个标签页之间的通信？

①WebSocket、SharedWorker；

②也可以调用localstorage、cookies等本地存储方式；使用localstorage在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，可以通过监听事件，控制它的值来进行页面信息通信；（注意：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常）



#### 怎么理解web worker？

在 HTML 页面中，如果正在执行脚本，则页面的状态是不可响应的，当脚本执行完成后，页面才变成可响应。而web worker是运行在后台的JS，独立于其它脚本，不会影响页面的性能，并通过 postMessage 将结果回传到主线程，这样在进行复杂操作的时候，就不会阻塞主线程了。

创建web worker：检测浏览器对于web worker的支持性，创建web worker文件（js、回传函数等），创建web worker对象。



#### 一个页面从输入 URL 到页面加载显示完成的过程？

分为以下步骤：

①当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求。同时进行DNS 域名解析（域名解析成ip地址，使浏览器获得请求对应的 IP 地址，走UTP协议，因此不会有握手过程），顺序是先本地浏览器的 DNS 缓存中查找，再向系统DNS缓存发送查询请求，再向路由器查询DNS缓存，再向网络运营商查询DNS缓存，再进行递归搜索。

②浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，然后服务器接受客户端的请求并进行响应，最后由客户端发出请求。

③一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求（浏览器向服务器发送一条 HTTP 请求报文），远程服务器找到资源并使用 HTTP 响应返回该资源（服务器返回给浏览器一条 HTTP 响应报文）。

④Web 服务器提供资源服务，客户端开始下载资源。

⑤HTTP报文在浏览器解析；

⑥浏览器进行页面渲染；

⑦连接结束，关闭 TCP 连接（四次挥手）；



#### 浏览器渲染的步骤？

①HTML 解析出 DOM Tree；②CSS 解析出 Style Rules；③两者关联生成 Render Tree；④Layout（布局）：根据 Render Tree 计算每个节点的信息；⑤Painting：根据计算好的信息进行渲染整个页面。

浏览器解析文档的过程中，如果遇到 script 标签，会立即解析脚本，停止解析文档（因为 JS 可能会改变 DOM 和 CSS，如果继续解析会造成浪费）。如果是外部 script，（默认）会等待脚本下载完成之后再继续解析文档。现在 script 标签增加了 defer 和 async 属性，脚本解析会将脚本中改变 DOM 和 css 的地方解析出来，追加到 DOM Tree 和 Style Rules 上。



#### 回流和重绘是什么？

回流：当 render tree 中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变而导致需要重新构建，这就叫回流。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候一定会发生回流，因为要构建render tree。

在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，这就是重绘。或当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，不会影响布局，也叫重绘。

回流必将引起重绘，而重绘不一定会引起回流。



#### 如何避免触发回流和重绘？

①避免频繁使用 style，而是采用修改 class 的方式。

②将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。

③可以先为元素设置 display: none ，操作结束后再把它显示出来，因为在 display 属性为 none 的元素上进行的DOM操作不会引发回流和重绘。

④使用 createDocumentFragment 进行批量的 DOM 操作。

⑤对于 resize、scroll 等进行防抖和节流处理。

⑥避免频繁读取会引发回流和重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。

⑦利用 CSS3 的transform、filter、opacity、visibility这些属性可以实现合成的效果，也就是 GPU 加速。

⑧避免使用 table 布局。

⑨如果动画速度快，回流次数多，则可以选择使用 requestAnimationFrame。

⑩CSS 选择符从右往左匹配查找，避免 DOM 深度过深。



#### 网页的三层结构有哪些？

结构（html 或 xhtm 标记语言），表现（css 样式表），行为（js）。



#### 从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？

dns缓存、cdn缓存、浏览器缓存、服务器缓存。



#### 浏览器缓存机制是怎样的？

缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。

强制缓存是在第一次请求资源时，在 http 响应头设置一个过期时间，在时效内都将直接从浏览 器进行获取，常见的 http 响应头字段如 Cache-Control（优先级更高）和 Expires。

协商缓存是通过 http 响应头字段Etag/If-None-Match（优先级更高）或Last-Modified/If-Modified-Since等，判断服务器上的资源是否修改，如果修改则从服务器重新获取，如果未修改则 304 并从浏览器缓存中进行获取。

使用协商缓存的时候，服务器需要考虑负载平衡的问题，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性，而多个服务器上资源的 Last-Modified 应该保持一致。



#### 怎么用Ajax避开浏览器缓存机制？

①在 ajax 发送请求前加上`anyAjaxObj.setRequestHeader("If-Modiied-Since","0")`。

②在 ajax 发送请求前加上`anyAjaxObj.setRequestHeader("Cache-Control","no-cache")`。

③在 URL 后面加上一个随机数，`"fresh=" + Math.random();`。

④在 URL 后面加上时间戳，`"nowtime=" + new Date().getTime();`。

⑤如果是使用 jQuery，则可使用`$.ajaxSetup({cache:false})`，这样页面的所有 ajax 都会执行这条语句且不保存缓存记录。



#### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢

在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件。

如果是第一次访问 app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。

如果已经访问过 app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。

离线的情况下，浏览器就直接使用离线存储的资源。



#### 什么是浏览器的标准模式和怪异模式？

标准模式：浏览器按照 W3C 标准解析执行代码。

怪异模式：浏览器根据自己的方式解析执行代码，因为不同浏览器解析执行方式不一样，所以叫怪异模式。



#### 解释在IE低版本下的怪异盒模型和c3的怪异盒模型?

在IE下，当padding+border的值小于width或height：盒模型的宽度=margin(左右)+width（width已经包含了padding和border的值），盒模型的高度=margin(上下)+height（height已经包含了padding和border的值）。当padding+border的值大于width或者height：盒模型的宽度=margin(左右)+padding(左右)+border(左右)，盒模型的高度=margin(上下)+padding(上下)+border(上下)+19px（加一个默认行高 19px）。所以相当于是padding+border和width或height比大小，谁大取谁。 无论使用哪种模式完整定义DOCTYPE，都会触发标准模式， 而如果DOCTYPE缺失，则在ie6、ie7、ie8下将会触发怪异模式（quirks 模式）。

`box-sizing`有三个值：content-box和border-box和inherit。当设置为content-box时，将采用标准模式解析计算，也是默认模式；当设置为border-box时，将采用怪异模式解析计算。



#### 怎么理解XSS攻击和CSRF攻击？

XSS（Cross Site Script）跨站脚本攻击，指的是攻击者向网页注入恶意的客户端代码，通过恶意的脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或获取用户隐私数据的一种攻击方式。

XSS主要是分为三种：
①存储型：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。
②反射型：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出，并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码。
③DOM型：将攻击脚本写在URL中，诱导用户点击该URL，如果URL被解析，那么攻击脚本就会被运行，DOM型攻击不用经过服务端。

防御XSS攻击：
①输入检查：对输入内容中的`script`和`<iframe>`等标签进行转义或过滤设置。
②httpOnly：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置cookie的httpOnly属性，则规定只能被服务器访问，可防止JS获取cookie。
③开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行。

CSRF（跨站点请求伪造），攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，即利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。

CSRF（Cross-site request forgery）跨站请求伪造，是一种劫持受信任用户，向服务器发送非预期请求的攻击方式。攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，即利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。通常情况下，它是攻击者借助受害者的 Cookie 骗取服务器的信任，但是它并不能拿到Cookie，也看不到Cookie的内容，它能做的就是给服务器发送请求，然后执行请求中所描述的命令，以此来改变服务器中的数据，也就是并不能窃取服务器中的数据。

防御CSRF攻击：
①验证 Token ：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求。
②验证 Referer ：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造。
③设置 SameSite ：设置cookie的SameSite，可以让cookie不随跨站请求发出，但浏览器兼容不一。

点击挟持：诱使用户点击看似无害的按钮（实则点击了透明于iframe的按钮），监听鼠标移动事件，让危险按钮始终在鼠标下方，使用 HTML5 拖拽技术执行敏感操作（如deploy key）。预防策略：服务端添加 X-Frame-Options 响应头，这个 HTTP 响应头是为了防御用 iframe 嵌套的点击劫持攻击，这样浏览器就会阻止嵌入网页的渲染；JS 判断顶层视口的域名是不是和本页面的域名一致（`top.location.hostname === self.location.hostname`），不一致则不允许操作；敏感操作使用更复杂的步骤（验证码、输入项目名称以删除）。



#### 什么叫优雅降级和渐进增强？

优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。

渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。





### 文件资源相关

#### 网络中使用最多的图片格式有哪些？

png-8，png-24，jpeg（有损压缩），gif（无损压缩），svg，Webp。最流行的是 jpeg 格式，可以把文件压缩到很小，在 ps 以 jpeg 格式存储时，提供 11 级压缩级别。

另外，WebP格式是谷歌（google）开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。



















## 基础具体实例分析题

### HTML

#### 实现不使用border画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？

```html
<div style="height:1px;overflow:hidden;background:red"></div>
```





### CSS

#### 三栏布局方式两边固定中间自适应？

①绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧， 中间的主体栏用左右 margin 值撑开距离。

②flex布局：左右固定宽 中间 flex：1。

③网格布局。

④table 布局。





### JS

#### 正则里的非如何是实现的？

如果`^`放在 [] 里则表示除了`^`后面的内容都能匹配，也就是非的意思。反之，如果`^`不在 [] 里则表示匹配`^`后面的内容。

```javascript
var str1 = 'lwqzwqzwq';
console.log(str1.replace(/[^l]/g, '帅')); // l帅帅帅帅帅帅帅帅
var str2 = 'lwqzwqzwq';
console.log(str2.replace(/^l/g, '帅')); // 帅wqzwqzwq
```



#### 常用的正则表达式有哪些？

①匹配 16 进制颜色值：`var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;`。

②匹配日期（yyyy-mm-dd格式）：`var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;`。

③匹配 qq 号：`var regex = /^[1-9][0-9]{4,10}$/g;`。

④手机号码正则：`var regex = /^1[34578]\d{9}$/g;`。

⑤用户名正则：`var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$/;`。



#### 什么是内部属性[[Class]]？

所有 typeof 返回值为 "object" 的对象都包含一个内部属性 [[Class]]，可以把它看作一个内部的分类，而非传统的面向对象意义上的类。

这个属性无法直接访问，一般通过`Object.prototype.toString(..)`来查看。

```javascript
Object.prototype.toString.call( [1,2,3] ); // "[object Array]"
Object.prototype.toString.call( /regex-literal/i ); // "[object RegExp]"
```



#### 怎么理解移动端的点击事件有延迟？

移动端点击有 300ms 的延迟是因为移动端会有双击缩放这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。

解决方法：
①通过 meta 标签禁用网页的缩放（`<meta name="viewport" content="width=device-width, user-scalable=no">`）。
②通过 meta 标签将网页的 viewport 设置为 ideal viewport。
③调用一些 js 库，如FastClick。

click 延时问题还可能引起点击穿透的问题，即在一个元素上注册了 touchStart 的监听事件，这个事件（点击时？）会将这个元素隐藏掉，当这个元素隐藏后就触发了这个元素下的一个元素的点击事件（点击穿透）。



#### 怎么理解`0.1 + 0.2 != 0.3`？

当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。

js 中是以 64 位双精度格式来存储数字的，且只有 53 位的有效数字，超过这个长度的位数会被截取掉，这样就造成了精度丢失的问题，这是第一个会造成精度丢失的地方。

在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。

当两个数据阶码对齐后，进行相加运算，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。

解决方式：
①对于这样的情况，可以将其转换为整数后再进行运算，运算后再转换为对应的小数。
②将两个数相加的结果和右边相减，如果相减的结果小于一个极小数（可以使用 es6 的`Number.EPSILON`），就可以认定结果是相等的。

例子：`0.1+0.2=0.30000000000000004`、`0.1+0.5=0.6`、`0.1+0.7=0.7999999999999999`、`0.3+0.2=0.5`、`1+2=3`。



#### 如何将浮点数点左边的数每三位添加一个逗号？

用正则：`number.replace(/(?!^)(?=(\d{3})+\.)/g, ",")`，如`12000000.11`转化为`12,000,000.11`。



#### `["1", "2", "3"].map(parseInt)`的结果是多少？

parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数（如果该值介于 2 ~ 36 之间，则字符串中的数字不能大于 radix 才能正确返回数字结果值）。

数组的map方法传了 3 个参数 (element, index, array)，而默认第三个参数会被忽略掉，因此三次传入的参数分别为`"1-0"`、`"2-1"`、`"3-2"`。第一次调用的基数为 0 ，按十进制解析返回 1，因为字符串的值不能大于基数，所以后面两次调用均失败，返回 NaN 。所以输出结果是`[1, NaN, NaN]`。



#### `[,,,]`的长度是多少？

如果使用了多于一个尾后逗号，会产生间隙，带有间隙的数组叫稀疏数组（密致数组没有间隙），稀疏数组的长度为逗号的数量。

尾后逗号（终止逗号）在向JS代码添加元素、参数、属性时十分有用。如果要添加新的属性，并且上一行已经使用了尾后逗号，可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。

JS一开始就支持数组字面值中的尾后逗号，ES6对对象字面值中添加了尾后逗号，ES8又对函数参数添加了尾后逗号。但是 JSON 不支持尾后逗号。



#### Promise相关的同步和异步？

```javascript
const promise = new Promise((resolve, reject) => {
 console.log(1)
 resolve()
 console.log(2)
})
promise.then(() => {
 console.log(3)
})
console.log(4)

输出结果是：1243
```





### React

#### 关于setState的输出题

```react
class Example extends React.Component {
	constructor() {
		super();
		this.state = {
			val: 0
		};
	}
    componentDidMount() {
        this.setState({ val: this.state.val + 1 });
        console.log(this.state.val); // 第 1 次 log
        this.setState({ val: this.state.val + 1 });
        console.log(this.state.val); // 第 2 次 log
        setTimeout(() => {
            this.setState({ val: this.state.val + 1 });
            console.log(this.state.val); // 第 3 次 log
            this.setState({ val: this.state.val + 1 });
            console.log(this.state.val); // 第 4 次 log
        }, 0);
    }
    render() {
        return null;
    }
};

第一次和第二次都是在 react 自身生命周期内，触发时的isBatchingUpdates为true，所以不会直接执行更新state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。然后，当真正执行这两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次，所以设置完成后 state.val 值为 1。
而setTimeout中的代码，触发时isBatchingUpdates为false，所以能够直接进行更新，所以连着输出 2，3。
输出为0 0 2 3
```





## 进阶手撕原理代码

### JS

#### 写一个通用的事件侦听器函数？

```javascript
const EventUtils = {
	// 添加事件
	addEvent: function (element, type, handler) { // 视能力分别使用dom0||dom2||IE方式 来绑定事件
		if (element.addEventListener) {
			element.addEventListener(type, handler, false);
		} else if (element.attachEvent) {
			element.attachEvent("on" + type, handler);
		} else {
			element["on" + type] = handler;
		}
	},
	// 移除事件
	removeEvent: function (element, type, handler) {
		if (element.removeEventListener) {
			element.removeEventListener(type, handler, false);
		} else if (element.detachEvent) {
			element.detachEvent("on" + type, handler);
		} else {
			element["on" + type] = null;
		}
	},
	// 获取事件目标
	getTarget: function (event) {
		return event.target || event.srcElement;
	},
	// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
	getEvent: function (event) {
		return event || window.event;
	},
	// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
	stopPropagation: function (event) {
		if (event.stopPropagation) {
			event.stopPropagation();
		} else {
			event.cancelBubble = true;
		}
	},
	// 取消事件的默认行为
	preventDefault: function (event) {
		if (event.preventDefault) {
			event.preventDefault();
		} else {
			event.returnValue = false;
		}
	}
};
```



#### 关于作用域和变量提升的输出案例？

```javascript
变量的赋值可以分为三个阶段：
①创建变量，在内存中开辟空间；
②（变量提升）初始化变量，将变量初始化为undefined；
③真正赋值。

let和const的「创建」过程提前了，但是初始化没有提前。var的「创建」和「初始化」都提前了。function的「创建」「初始化」和「赋值」都提前了。

如果是在任意函数的外部声明var变量，其作用域是全局的；
如果是在函数内部声明var，其作用域是局部的，只能在函数内部被访问；
let声明的变量只在它所处的代码块内有效，属于块级作用域。

案例：
console.log(name);
console.log(age);
var name = "Lydia";
let age = 21;
依次输出：
// undefined、Uncaught ReferenceError: age is not defined

案例：
let a = 10;
console.log(a)
console.log(window.a)
依次输出：
// 10、undefined

案例：
(function b() {
 console.log(a)
 console.log(window.a)
 var a = 20;
 console.log(a)
 console.log(window.a)
})()
console.log(window.a)
console.log(a)
依次输出：
// undefined、undefined、20、undefined、undefined、Uncaught ReferenceError: a is not defined

案例：
var a = 10;
(function b() {
 console.log(a)
 console.log(window.a)
 a = 5
 console.log(window.a)
 console.log(a)
 var a = 20;
 console.log(a)
})()
console.log(a)
依次输出：
// undefined、10、10、5、20、10

案例：
var a = 10;
(function b() {
 console.log(a)
 console.log(window.a)
 a = 5
 console.log(window.a)
 console.log(a)
})()
console.log(a)
依次输出：
// 10、10、5、5、5
```



#### 关于类的输出案例？

```javascript
案例：
class Chameleon {
	constructor({ newColor = "green" } = {}) { // 右边赋值给左边，右边对象没有相应属性就默认左边
		this.newColor = newColor;
        console.log(this.newColor)
	}
	static colorChange(newColor) {
		this.newColor = newColor;
	}
}
const freddie = new Chameleon({ newColor: "purple" });
freddie.colorChange("orange");

colorChange 方法是静态的，静态方法仅在构造函数中存在，且不能传递给任何子级。由于 freddie 是一个子级对象，函数不会传递，所以在 freddie 实例上不存在 freddie 方法：抛出 TypeError 
输出：
// purple、Uncaught TypeError: freddie.colorChange is not a function。
```



#### 关于数组和对象的输出案例？

```javascript
案例：
var obj = {
	2: 3,
	3: 4,
	length: 2,
	splice: Array.prototype.splice,
	push: Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)

使用第一次push，obj对象的push方法设置 obj[2]=1;obj.length+=1。
使用第二次push，obj对象的push方法设置 obj[3]=2;obj.length+=1。
使用console.log输出的时候，因为obj具有 length 属性和 splice 方法，故将其作为数组进行打印。
打印时因为数组未设置下标为 0 1 处的值，故打印为empty，主动 obj[0] 获取为 undefined。
输出：
// Object(4) [空属性 × 2, 1, 2, splice: ƒ, push: ƒ]
// 2: 1
// 3: 2
// length: 4
// push: ƒ push()
// splice: ƒ splice()
// [[Prototype]]: Object

案例：
var a = {n: 1};
var b = a;
a = {n: 2};
a.x = a
console.log(a.x)
console.log(b.x)
输出：
// { n: 2, x: { n: 2, x: {......} } }、undefined

案例：
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x)
console.log(b.x)
执行到`a.x = a = {n：2}`语句，尽管赋值是从右到左的没错，但是`.`的优先级比`=`要高，所以这里先执行a.x，相当于为a和b所指向的`{n:1}`对象新增了一个属性x，此时对象变为`{n:1;x:undefined}`。
之后按正常情况，从右到左进行赋值，执行`a = {n:2}`，a的引用指向了新对象`{n：2}`，而b依然指向的是旧对象。再执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用旧对象，并将旧对象的x赋值为{n：2}，旧对象为 {n:1;x:{n：2}}，被b引用着。
输出：
// undefined、{n:2}

案例：
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);
console.log(obj.hasOwnProperty("1"));
console.log(obj.hasOwnProperty(1));
console.log(set.has("1"));
console.log(set.has(1));
所有对象键（不包括 Symbols ）都会被存储为字符串（即使没有给定字符串类型的键），这就是为什么`obj.
hasOwnProperty(1)`也返回true。
输出：
// true true false true
```



#### 节流函数和防抖函数的区别？

函数节流是指一定时间内 js 方法只执行一次。函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。

函数节流是声明一个变量当标志位，记录当前代码是否在执行，如果正在执行，则取消这次方法执行，直接 return，如果空闲，则正常触发方法执行。

函数防抖是需要一个延时器来辅助实现，延迟执行需要执行的代码，如果方法多次触发，把上次记录的延迟执行代码用 cleartimeout 清除掉，重新开始，如果计时完毕之前都没有再次触发访问，则执行代码。

```javascript
// 函数防抖的实现：在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
function debounce(fn, wait) {
	var timer = null;
	return function () {
		var context = this,
			args = arguments;
		if (timer) { // 如果此时存在定时器的话，则取消之前的定时器重新记时
			clearTimeout(timer);
			timer = null;
		}
		timer = setTimeout(() => { // 设置定时器，使事件间隔指定时间后执行
			fn.apply(context, args);
		}, wait);
	};
}
// 函数节流的实现：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
function throttle(fn, delay) {
	var preTime = Date.now();
	return function () {
		var context = this,
			args = arguments,
			nowTime = Date.now();
		if (nowTime - preTime >= delay) { // 如果两次时间间隔超过了指定时间，则执行函数。
			preTime = Date.now();
			return fn.apply(context, args);
		}
	};
}
```



#### 实现一个防抖函数?

```javascript
// 思路:在规定时间内未触发第二次，则执行
function debounce(fn, delay) {
	// 利用闭包保存定时器
	let timer = null
	return function () {
		let context = this
		let arg = arguments
		// 在规定时间内再次触发会先清除定时器后再重设定时器
		clearTimeout(timer)
		timer = setTimeout(function () {
			fn.apply(context, arg)
		}, delay)
	}
}
function fn() {
	console.log('防抖')
}
addEventListener('scroll', debounce(fn, 1000))
```



#### 实现一个节流函数?

```javascript
// 思路：在规定时间内只触发一次
function throttle(fn, delay) {
	// 利用闭包保存时间
	let prev = Date.now()
	return function () {
		let context = this
		let arg = arguments
		let now = Date.now()
		if (now - prev >= delay) {
			fn.apply(context, arg)
			prev = Date.now()
		}
	}
}
function fn() {
	console.log('节流')
}
addEventListener('scroll', throttle(fn, 1000))
```



#### 实现new方法？

```javascript
/*
* 1.创建一个空对象
* 2.链接到原型
* 3.绑定this值
* 4.返回新对象
*/
function createNew() {
	let obj = {} // 1.创建一个空对象
	let constructor = [].shift.call(arguments)
	// let [constructor,...args] = [...arguments]
	obj.__proto__ = constructor.prototype // 2.链接到原型
    // result始终都是undefined
	let result = constructor.apply(obj, arguments) // 3.绑定this值
	// let result = constructor.apply(obj, args)
	return obj // 4.返回新对象
}
function People(name, age) {
	this.name = name
	this.age = age
}
let peo = createNew(People, 'Bob', 22)
console.log(peo.name)
console.log(peo.age)
```



#### 实现Promise？

```javascript
// 未添加异步处理等其它边界情况
// ①自动执行函数；②三个状态；③then；
class Promise {
	constructor(fn) {
		// 三个状态
		this.state = 'pending'
		this.value = undefined
		this.reason = undefined
		let resolve = value => {
			if (this.state === 'pending') {
				this.state = 'fulfilled'
				this.value = value
			}
		}
		let reject = value => {
			if (this.state === 'pending') {
				this.state = 'rejected'
				this.reason = value
			}
		}
		// 自动执行函数
		try {
			fn(resolve, reject)
		} catch (e) {
			reject(e)
		}
	}
	// then
	then(onFulfilled, onRejected) {
		switch (this.state) {
			case 'fulfilled':
				onFulfilled(this.value)
				break
			case 'rejected':
				onRejected(this.value)
				break
			default:
		}
	}
}
```



#### 有三个Promise（A、B和C），如何实现串行执行？

```javascript
// Promise方式
A.then(B).then(C).catch(...)
                        
// async/await方式
(async () => {
 await a();
 await b();
 await c();
})()
```



#### 实现一个 call 函数？

```javascript
// 思路：将要改变this指向的方法挂到目标this上执行并返回
Function.prototype.mycall = function (context) {
	if (typeof this !== 'function') {
		throw new TypeError('not funciton')
	}
	context = context || window
	context.fn = this
	let arg = [...arguments].slice(1)
	let result = context.fn(...arg)
	delete context.fn
	return result
}
```



#### 实现一个apply函数?

```javascript
// 思路：将要改变this指向的方法挂到目标this上执行并返回
Function.prototype.myapply = function (context) {
	if (typeof this !== 'function') {
		throw new TypeError('not funciton')
	}
	context = context || window
	context.fn = this
	let result
	if (arguments[1]) {
		result = context.fn(...arguments[1])
	} else {
		result = context.fn()
	}
	delete context.fn
	return result
}
```



#### 实现一个bind函数?

```javascript
// 注意：返回的是函数
Function.prototype.mybind = function (context) {
	if (typeof this !== 'function') {
		throw new TypeError('Error')
	}
	let _this = this
	let arg = [...arguments].slice(1)
	return function F() {
		// 处理函数使用new的情况
		if (this instanceof F) {
			return new _this(...arg, ...arguments)
		} else {
			return _this.apply(context, arg.concat(...arguments))
		}
	}
}

// 考虑到原型链（因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型）:
Function.prototype.bind = function(obj, arg) {
    var arg = Array.prototype.slice.call(arguments, 1);
    var context = this;
    var bound = function(newArg) {
        arg = arg.concat(Array.prototype.slice.call(newArg));
        return context.apply(obj, arg);
    }
    var F = function() { } // 这里需要一个寄生组合继承
    F.prototype = context.prototype;
    bound.prototype = new F();
    return bound;
}
```



#### 使用递归实现深拷贝？

```javascript
function deepClone(obj) {
	let copy = obj instanceof Array ? [] : {}
	for (let i in obj) {
		if (obj.hasOwnProperty(i)) {
			copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i]
		}
	}
	return copy
}
```



#### JS的设计模式的示例？

```javascript
// 工厂模式：用于为解决多个相似的问题
function CreatePerson(name, age, sex) {
	var obj = new Object();
	obj.name = name;
	obj.age = age;
	obj.sex = sex;
	obj.sayName = function () {
		return this.name;
	}
	return obj;
}

// 单例模式（单体模式）：只能被实例化一次，即构造函数只能给实例添加属性与方法一次：
var Singleton = function (name) {
	this.name = name;
};
Singleton.prototype.getName = function () {
	return this.name;
}
// 获取实例对象
var getInstance = (function () {
	var instance = null;
	return function (name) {
		if (!instance) { //相当于一个一次性阀门,只能实例化一次
			instance = new Singleton(name);
		}
		return instance;
	}
})();
// 测试单体模式的实例,所以a===b
var a = getInstance("aa");
var b = getInstance("bb");

// 沙箱模式：将一些函数放到自执行函数里面，但要用闭包暴露接口，且用变量接收暴露的接口，再调用里面的值，否则无法使用里面的值
let sandboxModel = (function () {
	function sayName() { };
	function sayAge() { };
	return { // 返回的变量是该对象
		sayName: sayName,
		sayAge: sayAge
	}
})()

// 发布订阅模式：
var shoeObj = {}; // 定义发布者
shoeObj.list = []; // 缓存列表 存放订阅者回调函数
// 增加订阅者
shoeObj.listen = function (fn) {
	shoeObj.list.push(fn); // 订阅消息添加到缓存列表
}
// 发布消息
shoeObj.trigger = function () {
	for (var i = 0, fn; fn = this.list[i++];) {
		fn.apply(this, arguments);//第一个参数只是改变fn的this,
	}
}
// A订阅如下消息
shoeObj.listen(function (color, size) {
	console.log("a" + color);
	console.log("aa" + size);
});
// B订阅如下消息
shoeObj.listen(function (color, size) {
	console.log("b" + color);
	console.log("bb" + size);
});
shoeObj.trigger("红色", 40); // a红色 a40 b红色 bb40
shoeObj.trigger("黑色", 42); // a黑色 a42 b黑色 bb42
```



#### 函数的柯里化示例？

```javascript
在函数式编程中，函数是一等公民。在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。即函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数的新函数（返回结
果）的技术。
函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。通常可用于在不侵入函数的前提下，为函数预置通用参数，供多次重复调用。

const add = function add(x) {
	return function (y) {
		return x + y
	}
}
const add1 = add(1)
add1(2) === 3
add1(20) === 21
```



#### `Object.create`的基本实现原理?

```javascript
// 思路：将传入的对象作为原型
function create(obj) {
	function F() { }
	F.prototype = obj
	return new F()
}
```



#### 实现一个基本的`Event Bus`?

```javascript
// 组件通信，一个监听与触发的过程
class EventEmitter {
	constructor() {
		// 存储事件
		this.events = this.events || new Map()
	}
	// 监听事件
	addListener(type, fn) {
		if (!this.events.get(type)) {
			this.events.set(type, fn)
		}
	}
	// 触发事件
	emit(type) {
		let handle = this.events.get(type)
		handle.apply(this, [...arguments].slice(1))
	}
}
// 测试
let emitter = new EventEmitter()
// 监听事件
emitter.addListener('ages', age => {
	console.log(age)
})
// 触发事件
emitter.emit('ages', 18) // 18
```



#### 懒加载的实现方法？

```javascript
<ul>
	<li><img src="./imgs/default.png" data="./imgs/1.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/2.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/3.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/4.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/5.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/6.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/7.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/8.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/9.png" alt=""></li>
	<li><img src="./imgs/default.png" data="./imgs/10.png" alt=""></li>
</ul>
let imgs = document.querySelectorAll('img')
// 可视区高度
let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
function lazyLoad() {
	// 滚动卷去的高度
	let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
	for (let i = 0; i < imgs.length; i++) {
		// 图片在可视区冒出的高度
		let x = clientHeight + scrollTop - imgs[i].offsetTop
		// 图片在可视区内
		if (x > 0 && x < clientHeight + imgs[i].height) {
			imgs[i].src = imgs[i].getAttribute('data')
		}
	}
}
// addEventListener('scroll', lazyLoad) or setInterval(lazyLoad, 1000)
```



#### 手写实现AJAX?

一个完整的Ajax请求包括五个步骤：

①创建 XMLHTTPRequest 对象，即创建一个异步调用对象。

②使用 open 方法创建 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息。

③设置响应 HTTP 请求状态变化的函数，并设置发送的数据，用 send 发送请求。

④获取异步调用返回的数据并使用 JS 和 DOM 实现局部刷新，即获取响应并更新页面。

```javascript
// 1. 简单流程
// 实例化
let xhr = new XMLHttpRequest()
// 初始化
xhr.open(method, url, async)
// 发送请求
xhr.send(data)
// 设置状态变化回调处理请求结果
xhr.onreadystatechange = () => {
	if (xhr.readyStatus === 4 && xhr.status === 200) {
		console.log(xhr.responseText)
	}
}
// 2. 基于promise实现
function ajax(options) {
	// 请求地址
	const url = options.url
	// 请求方法
	const method = options.method.toLocaleLowerCase() || 'get'
	// 默认为异步true
	const async = options.async
	// 请求参数
	const data = options.data
	// 实例化
	const xhr = new XMLHttpRequest()
	// 请求超时
	if (options.timeout && options.timeout > 0) {
		xhr.timeout = options.timeout
	}
	// 返回一个Promise实例
	return new Promise((resolve, reject) => {
		xhr.ontimeout = () => reject && reject('请求超时')
		// 监听状态变化回调
		xhr.onreadystatechange = () => {
			if (xhr.readyState == 4) {
				// 200-300 之间表示请求成功，304资源未变，取缓存
				if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
					resolve && resolve(xhr.responseText)
				} else {
					reject && reject()
				}
			}
		}
		// 错误回调
		xhr.onerror = err => reject && reject(err)
		let paramArr = []
		let encodeData
		// 处理请求参数
		if (data instanceof Object) {
			for (let key in data) {
				// 参数拼接需要通过 encodeURIComponent 进行编码
				paramArr.push(encodeURIComponent(key) + '=' +
					encodeURIComponent(data[key]))
			}
			encodeData = paramArr.join('&')
		}
		// get请求拼接参数
		if (method === 'get') {
			// 检测url中是否已存在 ? 及其位置
			const index = url.indexOf('?')
			if (index === -1) url += '?'
			else if (index !== url.length - 1) url += '&'
			// 拼接url
			url += encodeData
		}
		// 初始化
		xhr.open(method, url, async)
		// 发送请求
		if (method === 'get') xhr.send(null)
		else {
			// post 方式需要设置请求头
			xhr.setRequestHeader('Content-Type', 'application/x-www-formurlencoded;charset=UTF-8')
			xhr.send(encodeData)
		}
	})
}
```





### Vue



### React



## 选择题填空题判断题

### HTML

### CSS

### JS

### Vue

### React









